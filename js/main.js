// variables to catch "initial" state
var view = "PCs";
var selectedGeo = "PC";
var selectedRegionFilter = "all"; // get the region/country user is filtering the change over time line chart with

var data,
    searchData;

var dispatch = d3.dispatch("load", "viewChange", "geoSelection", "regionFilterChange");

d3.queue()
    .defer(d3.csv, "data/index_data.csv")
    // .defer(d3.json, "data/coc_bboxes.json")
    .defer(d3.csv, "data/search_data.csv")
.await(function(error, index_data, search_data) {

    if(error) throw error;

    // countyJson = county_bboxes;
    // cocJson = coc_bboxes;

    index_data.forEach(function(d) {
        d.average_credit_use = +d.average_credit_use,
        d.date = d3.timeParse("%Y-%m-%d")(d.date),
        d.financial_vulnerability_index = +d.financial_vulnerability_index,
        d.share_claiming_social_benefits = +d.share_claiming_social_benefits,
        d.share_of_lowell_consumers_in_default = +d.share_of_lowell_consumers_in_default,
        d.share_using_alternative_financial_products = +d.share_using_alternative_financial_products,
        d.share_with_subprime_lending = +d.share_with_subprime_lending,
        d.share_without_emergency_savings = +d.share_without_emergency_savings
    })

    // console.log(search_data);
    data = index_data;
    searchData = search_data;

    var mostRecentYear = d3.max(index_data, function(d) { return d.year; });
    var mostRecentQuarter = d3.max(index_data.filter(function(d) { return d.year === mostRecentYear}),
        function(d) { return d.quarter; });

    dispatch.call("load", this, index_data, search_data, mostRecentQuarter, mostRecentYear);
    // makeLineChart(index_data);
    // initializeSearchbox(searchData.filter(function(d) { return d.search_level === "PC"; }));

});

dispatch.on("load.changeOverTimeChart", function(index_data, search_data, mostRecentQuarter, mostRecentYear) {
    /*
     * Setup
     */
    const isMobile = false; // need to shift this later

    const aspectWidth = isMobile ? 3 : 6;
    const aspectHeight = isMobile ? 2 : 4;

    const width = d3.select("#lineChart").node().getBoundingClientRect().width;

    const margins = {
        top: 10,
        right: 12,
        bottom: 20,
        left: 20
    };

    const ticksX = 10;
    const ticksY = 5;
    const roundTicksFactor = 4;

    // Mobile
    if (isMobile) {
        ticksX = 5;
        ticksY = 5;
        margins['right'] = 25;
    }

    // Calculate actual chart dimensions
    const chartWidth = width - margins['left'] - margins['right'];
    const chartHeight = Math.ceil((width * aspectHeight) / aspectWidth) - margins['top'] - margins['bottom'];

    // // Clear existing graphic (for redraw)
    // const containerElement = d3.select(config['container']);
    // containerElement.html('');

    // Set x-position of the tooltip now that we know the chart width
    d3.select("#lineChart .tooltip").style("left", chartWidth + margins['left'] + margins['right'] + "px");

    // Nest data
    const dataSeries = d3.nest()
        .key(function(d) { return d.geo_name; })
        .entries(index_data);

    console.log(dataSeries);

    /*
     * Create D3 scale objects.
     */
    const xScale = d3.scaleTime()
        .domain(d3.extent(index_data.map(function(d) { return d.date; })))
        .range([ 0, chartWidth ]);

    const yScale = d3.scaleLinear()
        .domain(d3.extent(index_data.filter(function(d) { return d.geo === selectedGeo; }).map(function(d) { return d.financial_vulnerability_index; })))
        .range([chartHeight, 0]);

    // /*
    //  * Render y-axis title.
    //  */
    // const yAxisTitle = containerElement.append('div')
    //     .attr('class', 'axis-title')
    //     .text('Axis title here');

    /*
     * Create the root SVG element.
     */
    const chartElement = d3.select("#lineChart")
        .append('svg')
            .attr('width', chartWidth + margins['left'] + margins['right'])
            .attr('height', chartHeight + margins['top'] + margins['bottom'])
        .append('g')
            .attr('transform', 'translate(' + margins['left'] + ',' + margins['top'] + ')');

    /*
     * Create D3 axes.
     */
     // need to rethink best way to display quarters since d3 doesn't natively support them
    const xAxis = g => g
        .attr('transform', "translate(0," + chartHeight + ")")
        .call(d3.axisBottom(xScale)
            // .ticks(d3.timeYear)  // pass in a number or time interval that makes more sense for your data
            // .tickFormat((t, i) => (i % 2 !== 0) ? " " : d3.timeFormat('%Y')(t))  // label only every other tick mark to avoid overlapping label
            .tickSizeOuter(0));
        // .call(g => g.selectAll('.domain').remove());

    const yAxis = g => g
        .call(d3.axisLeft(yScale)
            .ticks(ticksY)
            .tickSize(-chartWidth))
        .call(g => g.selectAll('.domain')
            .remove());

    /*
     * Render axes to chart.
     */
    chartElement.append('g')
        .attr('class', 'x axis')
        .call(xAxis);

    chartElement.append('g')
        .attr('class', 'y axis')
        .call(yAxis);

    /*
     * Render lines to chart.
     */
    const line = d3.line()
        .defined(d => !isNaN(d["financial_vulnerability_index"]))
        .curve(d3.curveLinear)
        .x(d => xScale(d["date"]))
        .y(d => yScale(d["financial_vulnerability_index"]));

    const lines = chartElement.selectAll('path')
        .data(dataSeries)
        .enter()
        .append("path")
            .attr('class', function(d) { return "line " + d.values[0].geo + " " + d.values[0].geo_id; })
            .attr('d', function(d) { return line(d['values']); })
        .on('mouseover', function(d) { d3.selectAll("#lineChart .line").classed("highlighted", false);
                                       d3.select(this).classed('highlighted', true);
                                       var mostRecentQuarterData = d["values"].filter(function(d) { return d.year === mostRecentYear && d.quarter === mostRecentQuarter; })[0];
                                       populateTooltip(mostRecentQuarterData);
                                     })
        .on('mouseout', function() { d3.select(this).classed('highlighted', false);
                                     d3.select("#lineChart .tooltip").classed("hidden", true); });

    // add voronoi to make line selection easier

    /*
     * Hide all region lines on initial page load
     */
    d3.selectAll("#lineChart .line.region").classed("invisible", true);

    function populateTooltip(data) {
       d3.select("#lineChart .tooltip .score").text(data.financial_vulnerability_index);
       d3.select("#lineChart .tooltip .geoName").text(data.geo_name);
       d3.select("#lineChart .tooltip").style("top", yScale(data.financial_vulnerability_index) + "px");
       d3.select("#lineChart .tooltip").classed("hidden", false);

       // don't forget to add .moveToFront
    }

    dispatch.on("viewChange.changeOverTimeChart", function(view) {
        // update line chart when user switches between PC and region view
        // this resets any region filter that was applied
        if(view === "PC") {
            // show region/country filter above chart and reset to show all regions/countries
            d3.select(".changeOverTime .filters").classed("invisible", false);
            d3.select("#regionCountryFilter").property("value", "all");

            // show PC lines and hide region lines
            d3.selectAll("#lineChart .line.PC").classed("invisible", false);
            d3.selectAll("#lineChart .line.Region").classed("invisible", true);
        }
        else {
            // hide region/country filter when on region view
            d3.select(".changeOverTime .filters").classed("invisible", true);

            d3.selectAll("#lineChart .line.Region").classed("invisible", false);
            d3.selectAll("#lineChart .line.PC").classed("invisible", true);
        }

        // update y-axis scale
        yScale.domain(d3.extent(index_data.filter(function(d) { return d.geo == selectedGeo}).map(function(d) { return d.financial_vulnerability_index; }))).nice();

        // update y axis and position of lines
        d3.selectAll("#lineChart .y.axis")
            .transition()
            // .duration(3000)
            .call(d3.axisLeft(yScale).ticks(5).tickSize(-chartWidth))  // .ticks(5) is equal to ticksY - refactor later
            .call(function(g) { g.selectAll('.domain').remove(); });

        lines.transition()
            .attr("d", function(d) { return line(d["values"]); });
    });

    dispatch.on("regionFilterChange.changeOverTimeChart", function(selectedRegion) {
        // show only lines for PCs in selected region
        d3.selectAll("#lineChart .line")
            .classed("invisible", function(d) { return d["values"][0].country_or_region_id === selectedRegion ? false : true; });

        // update y-axis
        yScale.domain(d3.extent(index_data.filter(function(d) { return d.country_or_region_id === selectedRegion}).map(function(d) { return d.financial_vulnerability_index; }))).nice();

        // update y axis and position of lines
        d3.selectAll("#lineChart .y.axis")
            .transition()
            // .duration(3000)
            .call(d3.axisLeft(yScale).ticks(5).tickSize(-chartWidth))  // .ticks(5) is equal to ticksY - refactor later
            .call(function(g) { g.selectAll('.domain').remove(); });

        lines.transition()
            .attr("d", function(d) { return line(d["values"]); });
    });

    dispatch.on("geoSelection", function(search_term, selected_geo_id) {
        // highlight line belonging to the PC or region that was searched for
        // also show the tooltip with that geo's name and latest quarter's index value
        d3.selectAll("#lineChart .line").classed("highlighted", false);
        d3.select("#lineChart .line." + selected_geo_id).classed("highlighted", true);

        var selected_geo_data = d3.select("#lineChart .line." + selected_geo_id).datum();
        var mostRecentQuarterData = selected_geo_data["values"].filter(function(d) { return d.year === mostRecentYear && d.quarter === mostRecentQuarter; })[0]
        populateTooltip(mostRecentQuarterData);
    });
});




// EVENT LISTENERS
d3.selectAll("input[name='geoType']")
    .on("click", function() { view = getSelectedView();
                              dispatch.call("viewChange", this, view); });

d3.select("#regionCountryFilter")
    .on("change", function() { dispatch.call("regionFilterChange", this, d3.select(this).property("value")); });


dispatch.on("load.searchbox", function(index_data, search_data, mostRecentQuarter) {
    $("#locationSearch").autocomplete({
        source: search_data,
        search: function() {
            if(this.value.length < 4) {  // only display options after at least 4 characters are typed because this dataset is really big
                return false;
            }
        },
        select: function( event, ui ) {
            console.log(ui.item);
            $("#locationSearch").val(ui.item.label);   // need this so when user clicks on a county name instead of hitting the enter key, the full name is captured (otherwise, only typed letters will get captured)

            dispatch.call("geoSelection", this, ui.item.label, ui.item.id);
            // highlight line in change over time chart (and reset dropdown if necessary)
            // zoom in map
            // update panel next to map
            // update component small multiples at the bottom
        },
        // open: function( event, ui ) {
        //     d3.select("#magnifyGlass").style("visibility", "hidden");
        // },
        close: function( event, ui ) {
            // $("#countySearch").val("");
        //     d3.select("#magnifyGlass").style("visibility", "visible");
        }
    });

    dispatch.on("viewChange.searchbox", function(view) {
        // clear searchbox contents
        $("#locationSearch").val("");

        // update placeholder text

        // update search data
        $("#locationSearch").autocomplete({
            source: search_data.filter(function(d) { return d.search_level === view; })
        });
    });
});

function getSelectedView() {
    return d3.select("input[name='geoType']:checked").node().value;
}

