// variables to catch "initial" state
var view = "PC";
var selectedGeo = "PC";
var selectedRegionFilter = "all"; // get the region/country user is filtering the change over time line chart with

var data,
    searchData;

var dispatch = d3.dispatch("load", "viewChange", "geoSelection", "regionFilterChange");

d3.queue()
    .defer(d3.csv, "data/index_data.csv")
    // .defer(d3.json, "data/coc_bboxes.json")
    .defer(d3.csv, "data/search_data.csv")
.await(function(error, index_data, search_data) {

    if(error) throw error;

    // countyJson = county_bboxes;
    // cocJson = coc_bboxes;

    index_data.forEach(function(d) {
        d.average_credit_use = +d.average_credit_use,
        d.date = d3.timeParse("%Y-%m-%d")(d.date),
        d.financial_vulnerability_index = +d.financial_vulnerability_index,
        d.share_claiming_social_benefits = +d.share_claiming_social_benefits,
        d.share_of_lowell_consumers_in_default = +d.share_of_lowell_consumers_in_default,
        d.share_using_alternative_financial_products = +d.share_using_alternative_financial_products,
        d.share_with_subprime_lending = +d.share_with_subprime_lending,
        d.share_without_emergency_savings = +d.share_without_emergency_savings
    })

    // console.log(search_data);
    // data = index_data;
    // searchData = search_data;

    var mostRecentYear = d3.max(index_data, function(d) { return d.year; });
    var mostRecentQuarter = d3.max(index_data.filter(function(d) { return d.year === mostRecentYear}),
        function(d) { return d.quarter; });

    dispatch.call("load", this, index_data, search_data, mostRecentQuarter, mostRecentYear);
    // makeLineChart(index_data);
    // initializeSearchbox(searchData.filter(function(d) { return d.search_level === "PC"; }));

});

dispatch.on("load.changeOverTimeChart", function(index_data, search_data, mostRecentQuarter, mostRecentYear) {
    /*
     * Setup
     */
    const isMobile = false; // need to shift this later

    const aspectWidth = isMobile ? 3 : 6;
    const aspectHeight = isMobile ? 2 : 4;

    const width = d3.select("#lineChart").node().getBoundingClientRect().width;

    const margins = {
        top: 10,
        right: 15,
        bottom: 20,
        left: 20
    };

    const ticksX = 10;
    const ticksY = 5;
    const roundTicksFactor = 4;

    // Mobile
    if (isMobile) {
        ticksX = 5;
        ticksY = 5;
        margins['right'] = 25;
    }

    // Calculate actual chart dimensions
    const chartWidth = width - margins['left'] - margins['right'];
    const chartHeight = Math.ceil((width * aspectHeight) / aspectWidth) - margins['top'] - margins['bottom'];

    // // Clear existing graphic (for redraw)
    // const containerElement = d3.select(config['container']);
    // containerElement.html('');

    // Set x-position of the tooltip now that we know the chart width
    d3.select("#lineChart .tooltip").style("left", chartWidth + margins['left'] + margins['right'] + "px");

    // Nest data
    const dataSeries = d3.nest()
        .key(function(d) { return d.geo_name; })
        .entries(index_data);

    // console.log(dataSeries.length);

    /*
     * Create D3 scale objects.
     */
    const xScale = d3.scaleTime()
        .domain(d3.extent(index_data.map(function(d) { return d.date; })))
        .range([ 0, chartWidth ]);

    const yScale = d3.scaleLinear()
        .domain(d3.extent(index_data.filter(function(d) { return d.geo === selectedGeo; }).map(function(d) { return d.financial_vulnerability_index; })))
        .range([chartHeight, 0]);

    // /*
    //  * Render y-axis title.
    //  */
    // const yAxisTitle = containerElement.append('div')
    //     .attr('class', 'axis-title')
    //     .text('Axis title here');

    /*
     * Create the root SVG element.
     */
    const chartElement = d3.select("#lineChart")
        .append('svg')
            .attr('width', chartWidth + margins['left'] + margins['right'])
            .attr('height', chartHeight + margins['top'] + margins['bottom'])
        .append('g')
            .attr('transform', 'translate(' + margins['left'] + ',' + margins['top'] + ')');

    /*
     * Create D3 axes.
     */
     // need to rethink best way to display quarters since d3 doesn't natively support them
    const xAxis = g => g
        .attr('transform', "translate(0," + chartHeight + ")")
        .call(d3.axisBottom(xScale)
            // .ticks(d3.timeYear)  // pass in a number or time interval that makes more sense for your data
            // .tickFormat((t, i) => (i % 2 !== 0) ? " " : d3.timeFormat('%Y')(t))  // label only every other tick mark to avoid overlapping label
            .tickSizeOuter(0));

    const yAxis = g => g
        .call(d3.axisLeft(yScale)
            .ticks(ticksY)
            .tickSize(-chartWidth))
        .call(g => g.selectAll('.domain')
            .remove());

    /*
     * Render axes to chart.
     */
    chartElement.append('g')
        .attr('class', 'y axis')
        .call(yAxis);

    chartElement.append('g')
        .attr('class', 'x axis')
        .call(xAxis);

    /*
     * Render lines to chart.
     */
    const line = d3.line()
        .defined(d => !isNaN(d["financial_vulnerability_index"]))
        .curve(d3.curveLinear)
        .x(d => xScale(d["date"]))
        .y(d => yScale(d["financial_vulnerability_index"]));

    const lines = chartElement.selectAll('.line')
        .data(dataSeries)
        .enter()
        .append("path")
            .attr('class', function(d) { return "line " + d.values[0].geo + " " + d.values[0].geo_id; })
            .attr('d', function(d) { return line(d['values']); })
        .on('mouseover', function(d) { d3.selectAll("#lineChart .line").classed("highlighted", false);
                                       d3.select(this).classed('highlighted', true);
                                       var mostRecentQuarterData = d["values"].filter(function(d) { return d.year === mostRecentYear && d.quarter === mostRecentQuarter; })[0];
                                       populateTooltip(mostRecentQuarterData);
                                     })
        .on('mouseout', function() { d3.select(this).classed('highlighted', false);
                                     d3.select("#lineChart .tooltip").classed("hidden", true); });

    // add voronoi to make line selection easier

    /*
     * Hide all region lines on initial page load
     */
    d3.selectAll("#lineChart .line.region").classed("invisible", true);

    function populateTooltip(data) {
       d3.select("#lineChart .tooltip .score").text(data.financial_vulnerability_index);
       d3.select("#lineChart .tooltip .geoName").text(data.geo_name);
       d3.select("#lineChart .tooltip").style("top", yScale(data.financial_vulnerability_index) + "px");
       d3.select("#lineChart .tooltip").classed("hidden", false);

       // don't forget to add .moveToFront
    }

    dispatch.on("viewChange.changeOverTimeChart", function(view) {
        // update line chart when user switches between PC and region view
        // this resets any region filter that was applied
        if(view === "PC") {
            // show region/country filter above chart and reset to show all regions/countries
            d3.select(".changeOverTime .filters").classed("invisible", false);
            d3.select("#regionCountryFilter").property("value", "all");

            // show PC lines and hide region lines
            d3.selectAll("#lineChart .line.PC").classed("invisible", false);
            d3.selectAll("#lineChart .line.Region").classed("invisible", true);
        }
        else {
            // hide region/country filter when on region view
            d3.select(".changeOverTime .filters").classed("invisible", true);

            d3.selectAll("#lineChart .line.Region").classed("invisible", false);
            d3.selectAll("#lineChart .line.PC").classed("invisible", true);
        }

        // update y-axis scale
        yScale.domain(d3.extent(index_data.filter(function(d) { return d.geo == selectedGeo}).map(function(d) { return d.financial_vulnerability_index; }))).nice();

        // update y axis and position of lines
        d3.selectAll("#lineChart .y.axis")
            .transition()
            // .duration(3000)
            .call(d3.axisLeft(yScale).ticks(5).tickSize(-chartWidth))  // .ticks(5) is equal to ticksY - refactor later
            .call(function(g) { g.selectAll('.domain').remove(); });

        lines.transition()
            .attr("d", function(d) { return line(d["values"]); });

        // hide any tooltips that are visible and make sure no lines are highlighted
        d3.select("#lineChart .tooltip").classed("hidden", true);
        d3.selectAll("#lineChart .line").classed("highlighted", false);
    });

    dispatch.on("regionFilterChange.changeOverTimeChart", function(selectedRegion) {
        // show only lines for PCs in selected region
        d3.selectAll("#lineChart .line")
            .classed("invisible", function(d) { return d["values"][0].country_or_region_id === selectedRegion ? false : true; });

        // update y-axis
        yScale.domain(d3.extent(index_data.filter(function(d) { return d.country_or_region_id === selectedRegion}).map(function(d) { return d.financial_vulnerability_index; }))).nice();

        // update y axis and position of lines
        d3.selectAll("#lineChart .y.axis")
            .transition()
            // .duration(3000)
            .call(d3.axisLeft(yScale).ticks(5).tickSize(-chartWidth))  // .ticks(5) is equal to ticksY - refactor later
            .call(function(g) { g.selectAll('.domain').remove(); });

        lines.transition()
            .attr("d", function(d) { return line(d["values"]); });
    });

    dispatch.on("geoSelection.changeOverTimeChart", function(search_term, selected_geo_id) {
        // if user searched for a PC, show all PC lines if not already (i.e., override region filter and reset chart)
        if(view === "PCs") {
            d3.selectAll("#lineChart .line.PC").classed("invisible", false);
            d3.select("#regionCountryFilter").property("value", "all");

             // update y-axis scale
            yScale.domain(d3.extent(index_data.filter(function(d) { return d.geo == "PC"}).map(function(d) { return d.financial_vulnerability_index; }))).nice();

            // update y axis and position of lines
            d3.selectAll("#lineChart .y.axis")
                .transition()
                // .duration(3000)
                .call(d3.axisLeft(yScale).ticks(5).tickSize(-chartWidth))  // .ticks(5) is equal to ticksY - refactor later
                .call(function(g) { g.selectAll('.domain').remove(); });

            lines.transition()
                .attr("d", function(d) { return line(d["values"]); });
        }

        // highlight line belonging to the PC or region that was searched for
        // also show the tooltip with that geo's name and latest quarter's index value
        d3.selectAll("#lineChart .line").classed("highlighted", false);
        d3.select("#lineChart .line." + selected_geo_id).classed("highlighted", true);

        var selected_geo_data = d3.select("#lineChart .line." + selected_geo_id).datum();
        var mostRecentQuarterData = selected_geo_data["values"].filter(function(d) { return d.year === mostRecentYear && d.quarter === mostRecentQuarter; })[0]
        populateTooltip(mostRecentQuarterData);
    });
});

dispatch.on("load.componentsCharts", function(index_data, search_data, mostRecentQuarter, mostRecentYear) {
    // Chart setup - TODO: turn this into a config object
    const isMobile = false; // need to shift this later

    const aspectWidth = isMobile ? 3 : 6;
    const aspectHeight = isMobile ? 2 : 4;

    const width = 300;

    const margins = {
        top: 10,
        right: 12,
        bottom: 20,
        left: 25
    };

    const ticksX = 10;
    const ticksY = 5;
    const roundTicksFactor = 4;

    // Mobile
    if (isMobile) {
        ticksX = 5;
        ticksY = 5;
        margins['right'] = 25;
    }

    // Calculate actual chart dimensions
    const chartWidth = width - margins['left'] - margins['right'];
    const chartHeight = Math.ceil((width * aspectHeight) / aspectWidth) - margins['top'] - margins['bottom'];

    // Filter data to the series we need and then Nest
    const filteredData = index_data.filter(function(d) { return d.geo === "National"; });

    const dataSeries = d3.nest()
        .key(function(d) { return d.geo; })
        .entries(filteredData);

    makeLineChart("financialVulnerabilityIndexChart", "financial_vulnerability_index", dataSeries, chartWidth, chartHeight, margins, ticksY);
    makeLineChart("consumersDefaultChart", "share_of_lowell_consumers_in_default", dataSeries, chartWidth, chartHeight, margins, ticksY);
    makeLineChart("socialBenefitsChart", "share_claiming_social_benefits", dataSeries, chartWidth, chartHeight, margins, ticksY);
    makeLineChart("subprimeLendingChart", "share_with_subprime_lending", dataSeries, chartWidth, chartHeight, margins, ticksY);
    makeLineChart("creditUseChart", "average_credit_use", dataSeries, chartWidth, chartHeight, margins, ticksY);

    // For the stick chart, filter data down to just one quarter
    var stickChartData = filteredData.filter(function(d) { return d.quarter === mostRecentQuarter && d.year === mostRecentYear; });

    makeStickChart("emergencySavingsChart", "share_without_emergency_savings", stickChartData, chartWidth, margins);
    makeStickChart("altFinancialProductsChart", "share_using_alternative_financial_products", stickChartData, chartWidth, margins);

    dispatch.on("viewChange.componentsCharts", function(view) {
        // when the user switches to a new view, reset the charts to only show the UK average
        var data = index_data.filter(function(d) { return d.geo === "National"; });

        var newDataSeries = d3.nest()
            .key(function(d) { return d.geo; })
            .entries(data);

        updateLineChart("financialVulnerabilityIndexChart", "financial_vulnerability_index", newDataSeries, chartWidth, chartHeight, margins, ticksY);
        updateLineChart("consumersDefaultChart", "share_of_lowell_consumers_in_default", newDataSeries, chartWidth, chartHeight, margins, ticksY);
        updateLineChart("socialBenefitsChart", "share_claiming_social_benefits", newDataSeries, chartWidth, chartHeight, margins, ticksY);
        updateLineChart("subprimeLendingChart", "share_with_subprime_lending", newDataSeries, chartWidth, chartHeight, margins, ticksY);
        updateLineChart("creditUseChart", "average_credit_use", newDataSeries, chartWidth, chartHeight, margins, ticksY);

        // subset data to most recent quarter for the stick charts
        var stickChartData = data.filter(function(d) { return d.quarter === mostRecentQuarter && d.year === mostRecentYear; });

        // update stick charts
        updateStickChart("emergencySavingsChart", "share_without_emergency_savings", stickChartData, chartWidth, chartHeight);
        updateStickChart("altFinancialProductsChart", "share_using_alternative_financial_products", stickChartData, chartWidth);

    });

    dispatch.on("geoSelection.componentsCharts", function(search_term, selected_geo_id) {
        // build dataset for selected geo
        // if on PC view, dataset should have national, PC and regional data
        // if on region view, dataset should have national and regional data
        var data = [];
        var nationalData = index_data.filter(function(d) { return d.geo === "National"; });

        if(view === "PC") {
            var pcData = index_data.filter(function(d) { return d.geo_id === selected_geo_id; });
            var region_id = pcData[0].country_or_region_id;
            var regionData = index_data.filter(function(d) { return d.geo_id === region_id; });
            data = data.concat(nationalData, pcData, regionData);
        }
        else if(view === "Region") {
            var regionData = index_data.filter(function(d) { return d.geo_id === selected_geo_id; });
            data = data.concat(nationalData, regionData);
        }

        var newDataSeries = d3.nest()
            .key(function(d) { return d.geo; })
            .entries(data);

        // update line charts
        updateLineChart("financialVulnerabilityIndexChart", "financial_vulnerability_index", newDataSeries, chartWidth, chartHeight, ticksY);
        updateLineChart("consumersDefaultChart", "share_of_lowell_consumers_in_default", newDataSeries, chartWidth, chartHeight, ticksY);
        updateLineChart("socialBenefitsChart", "share_claiming_social_benefits", newDataSeries, chartWidth, chartHeight, ticksY);
        updateLineChart("subprimeLendingChart", "share_with_subprime_lending", newDataSeries, chartWidth, chartHeight, ticksY);
        updateLineChart("creditUseChart", "average_credit_use", newDataSeries, chartWidth, chartHeight, ticksY);

        // subset data to most recent quarter for the stick charts
        var stickChartData = data.filter(function(d) { return d.quarter === mostRecentQuarter && d.year === mostRecentYear; });

        // update stick charts
        updateStickChart("emergencySavingsChart", "share_without_emergency_savings", stickChartData, chartWidth, chartHeight);
        updateStickChart("altFinancialProductsChart", "share_using_alternative_financial_products", stickChartData, chartWidth);
    });
});

function makeLineChart(elementID, metric, data, chartWidth, chartHeight, margins, ticksY) {
    /*
     * Create D3 scale objects.
     */
    const xScale = d3.scaleTime()
        .domain(d3.extent(data[0]['values'].map(function(d) { return d.date; })))
        .range([ 0, chartWidth ]);

    const yScale = d3.scaleLinear()
        .domain([0, 100])
        .range([chartHeight, 0]);

    /*
     * Create the root SVG element.
     */
    const chartElement = d3.select("#" + elementID)
        .append('svg')
            .attr('width', chartWidth + margins['left'] + margins['right'])
            .attr('height', chartHeight + margins['top'] + margins['bottom'])
        .append('g')
            .attr('transform', 'translate(' + margins['left'] + ',' + margins['top'] + ')');

    /*
     * Create D3 axes.
     */
     const yAxis = g => g
        .call(d3.axisLeft(yScale)
            .ticks(ticksY)
            .tickSize(-chartWidth))
        .call(g => g.selectAll('.domain')
            .remove());
     // need to rethink best way to display quarters since d3 doesn't natively support them
    const xAxis = g => g
        .attr('transform', "translate(0," + chartHeight + ")")
        .call(d3.axisBottom(xScale)
            // .ticks(d3.timeYear)  // pass in a number or time interval that makes more sense for your data
            // .tickFormat((t, i) => (i % 2 !== 0) ? " " : d3.timeFormat('%Y')(t))  // label only every other tick mark to avoid overlapping label
            .tickSizeOuter(0));

    /*
     * Render axes to chart.
     */
    chartElement.append('g')
        .attr('class', 'y axis')
        .call(yAxis);

    chartElement.append('g')
        .attr('class', 'x axis')
        .call(xAxis);

    /*
     * Render lines to chart.
     */
    const line = d3.line()
        .defined(d => !isNaN(d[metric]))
        .curve(d3.curveLinear)
        .x(d => xScale(d["date"]))
        .y(d => yScale(d[metric]));

    const lines = chartElement.selectAll('.line')
        .data(data, function(d) { return d.key; })
        .enter()
        .append("path")
            .attr('class', function(d) { return "line " + d.key; })
            .attr('d', function(d) { return line(d['values']); });
        // .append("text")
        //     .attr("x", width)
        //     .attr("y", yScale(50))
        //     .text(function(d) { return d.key; });
}

function updateLineChart(elementID, metric, data, chartWidth, chartHeight, ticksY) {
    const xScale = d3.scaleTime()
        .domain(d3.extent(data[0]['values'].map(function(d) { return d.date; })))
        .range([ 0, chartWidth ]);

    const yScale = d3.scaleLinear()
        .domain([0, 100])
        .range([chartHeight, 0]);

    const line = d3.line()
        .defined(d => !isNaN(d[metric]))
        .curve(d3.curveLinear)
        .x(d => xScale(d["date"]))
        .y(d => yScale(d[metric]));

    var lines = d3.select("#" + elementID + " svg g")
        .selectAll(".line")
        .data(data, function(d) { return d.key; });

    lines.exit().remove();

    lines.enter()
        .append("path")
        .attr("class", function(d) { return "line " + d.key; })
        .merge(lines)
        .transition()
        .attr("d", function(d) { return line(d.values); });
        // .attrTween("d", function(d) {
        //     var previous = d3.select(this).attr("d");
        //     var current = line(d.values);
        //     return d3.interpolatePath(previous, current);
        // });
}

function makeStickChart(elementID, metric, data, chartWidth, margins) {

    // make the top "table" of numbers and place names
    var table = d3.select("#" + elementID)
        .append("div")
        .attr("class", "container");

    var columns = table.selectAll(".column")
        .data(data)
        .enter()
        .append("div")
        .attr("class", function(d) { return "column " + d.geo; });

    columns.append("div")
        .attr("class", "number")
        .text(function(d) { return d[metric]; });

    columns.append("div")
        .attr("class", "geoName")
        .text(function(d) { return d.geo_name; });

    // make stick chart
    var chartHeight = 15;

    const xScale = d3.scaleLinear()
        .domain([0, 100])
        .range([0, chartWidth]);

    var chartElement = d3.select("#" + elementID)
        .append("svg")
            .attr('width', chartWidth + margins['left'] + margins['right'])
            .attr('height', chartHeight + margins['top'] + margins['bottom'])
        .append('g')
            .attr('transform', 'translate(' + margins['left'] + ',' + margins['top'] + ')');

    const xAxis = g => g
        .attr('transform', "translate(0," + chartHeight + ")")
        .call(d3.axisBottom(xScale)
            .ticks(5)
            .tickSizeOuter(0));

    /*
     * Render axes to chart.
     */
    chartElement.append('g')
        .attr('class', 'x axis')
        .call(xAxis);

    var sticks = chartElement.selectAll(".stick")
        .data(data, function(d) { return d.geo; })
        .enter()
        .append("line")
            .attr("class", function(d) { return "stick " + d.geo ; })
            .attr("x1", function(d) { return xScale(d[metric]); })
            .attr("x2", function(d) { return xScale(d[metric]); })
            .attr("y1", 0)
            .attr("y2", chartHeight);
}

function updateStickChart(elementID, metric, data, chartWidth) {
    const xScale = d3.scaleLinear()
        .domain([0, 100])
        .range([0, chartWidth]);

    var sticks = d3.select("#" + elementID + " svg g")
        .selectAll(".stick")
        .data(data, function(d) { return d.geo; });

    sticks.exit().remove();

    sticks.enter()
        .append("line")
        .attr("class", function(d) { return "stick " + d.geo; })
        .merge(sticks)
        .transition()
            .attr("class", function(d) { return "stick " + d.geo ; })
            .attr("x1", function(d) { return xScale(d[metric]); })
            .attr("x2", function(d) { return xScale(d[metric]); })
            .attr("y1", 0)
            .attr("y2", 15);
}

// EVENT LISTENERS
d3.selectAll("input[name='geoType']")
    .on("click", function() { view = getSelectedView();
                              dispatch.call("viewChange", this, view); });

d3.select("#regionCountryFilter")
    .on("change", function() { dispatch.call("regionFilterChange", this, d3.select(this).property("value")); });


dispatch.on("load.searchbox", function(index_data, search_data, mostRecentQuarter) {
    $("#locationSearch").autocomplete({
        source: search_data,
        search: function() {
            if(this.value.length < 4) {  // only display options after at least 4 characters are typed because this dataset is really big
                return false;
            }
        },
        select: function( event, ui ) {
            console.log(ui.item);
            $("#locationSearch").val(ui.item.label);   // need this so when user clicks on a county name instead of hitting the enter key, the full name is captured (otherwise, only typed letters will get captured)

            dispatch.call("geoSelection", this, ui.item.label, ui.item.id);
            // highlight line in change over time chart (and reset dropdown if necessary)
            // zoom in map
            // update panel next to map
            // update component small multiples at the bottom
        },
        // open: function( event, ui ) {
        //     d3.select("#magnifyGlass").style("visibility", "hidden");
        // },
        close: function( event, ui ) {
            // $("#countySearch").val("");
        //     d3.select("#magnifyGlass").style("visibility", "visible");
        }
    });

    dispatch.on("viewChange.searchbox", function(view) {
        // clear searchbox contents
        $("#locationSearch").val("");

        // update placeholder text

        // update search data
        $("#locationSearch").autocomplete({
            source: search_data.filter(function(d) { return d.search_level === view; })
        });
    });
});

function getSelectedView() {
    return d3.select("input[name='geoType']:checked").node().value;
}

