// variables to catch "initial" state
var view = "PCs";
var selectedGeo = null;

d3.queue()
    .defer(d3.csv, "data/index_data.csv")
    // .defer(d3.json, "data/coc_bboxes.json")
    // .defer(d3.csv, "data/geos.csv")
.await(function(error, index_data/*, coc_bboxes, geos*/) {

    if(error) throw error;

    // countyJson = county_bboxes;
    // cocJson = coc_bboxes;

    index_data.forEach(function(d) {
        d.average_credit_use = +d.average_credit_use,
        d.date = d3.timeParse("%Y-%m-%d")(d.date),
        d.financial_vulnerability_index = +d.financial_vulnerability_index,
        d.share_claiming_social_benefits = +d.share_claiming_social_benefits,
        d.share_of_lowell_consumers_in_default = +d.share_of_lowell_consumers_in_default,
        d.share_using_alternative_financial_products = +d.share_using_alternative_financial_products,
        d.share_with_subprime_lending = +d.share_with_subprime_lending,
        d.share_without_emergency_savings = +d.share_without_emergency_savings
    })

    // console.log(index_data);

    makeLineChart(index_data);

});

function makeLineChart(data) {
    /*
     * Setup
     */
    const isMobile = false; // need to shift this later

    const aspectWidth = isMobile ? 4 : 16;
    const aspectHeight = isMobile ? 3 : 9;

    const width = d3.select("#lineChart").node().getBoundingClientRect().width;

    const margins = {
        top: 10,
        right: 12,
        bottom: 20,
        left: 20
    };

    const ticksX = 10;
    const ticksY = 5;
    const roundTicksFactor = 4;

    // Mobile
    if (isMobile) {
        ticksX = 5;
        ticksY = 5;
        margins['right'] = 25;
    }

    // Calculate actual chart dimensions
    const chartWidth = width - margins['left'] - margins['right'];
    const chartHeight = Math.ceil((width * aspectHeight) / aspectWidth) - margins['top'] - margins['bottom'];

    // // Clear existing graphic (for redraw)
    // const containerElement = d3.select(config['container']);
    // containerElement.html('');

    // Nest data
    const dataSeries = d3.nest()
        .key(function(d) { return d.geo_name; })
        .entries(data);

    console.log(dataSeries);

    /*
     * Create D3 scale objects.
     */
    const xScale = d3.scaleTime()
        .domain(d3.extent(data.map(function(d) { return d.date; })))
        .range([ 0, chartWidth ]);

    const yScale = d3.scaleLinear()
        .domain(d3.extent(data.map(function(d) { return d.financial_vulnerability_index; })))
        .range([chartHeight, 0]);

    // /*
    //  * Render y-axis title.
    //  */
    // const yAxisTitle = containerElement.append('div')
    //     .attr('class', 'axis-title')
    //     .text('Axis title here');

    /*
     * Create the root SVG element.
     */
    const chartElement = d3.select("#lineChart")
        .append('svg')
            .attr('width', chartWidth + margins['left'] + margins['right'])
            .attr('height', chartHeight + margins['top'] + margins['bottom'])
        .append('g')
            .attr('transform', 'translate(' + margins['left'] + ',' + margins['top'] + ')');

    /*
     * Create D3 axes.
     */
     // need to rethink best way to display quarters since d3 doesn't natively support them
    const xAxis = g => g
        .attr('transform', "translate(0," + chartHeight + ")")
        .call(d3.axisBottom(xScale)
            // .ticks(d3.timeYear)  // pass in a number or time interval that makes more sense for your data
            // .tickFormat((t, i) => (i % 2 !== 0) ? " " : d3.timeFormat('%Y')(t))  // label only every other tick mark to avoid overlapping label
            .tickSizeOuter(0));
        // .call(g => g.selectAll('.domain').remove());

    const yAxis = g => g
        .call(d3.axisLeft(yScale)
            .ticks(ticksY)
            .tickSize(-chartWidth))
        .call(g => g.selectAll('.domain')
            .remove());

    /*
     * Render axes to chart.
     */
    chartElement.append('g')
        .attr('class', 'x axis')
        .call(xAxis);

    chartElement.append('g')
        .attr('class', 'y axis')
        .call(yAxis);

    /*
     * Render lines to chart.
     */
    const line = d3.line()
        .defined(d => !isNaN(d["financial_vulnerability_index"]))
        .curve(d3.curveLinear)
        .x(d => xScale(d["date"]))
        .y(d => yScale(d["financial_vulnerability_index"]));

    const lines = chartElement.selectAll('path')
        .data(dataSeries)
        .enter()
        .append("path")
            .attr('class', function(d) { return "line " + d.values[0].geo + " " + d.values[0].geo_id; })
            .attr('d', function(d) { return line(d['values']); });

    /*
     * Hide all region lines on initial page load
     */
    d3.selectAll("#lineChart .line.region").classed("invisible", true);
}

d3.selectAll("input[name='geoType']")
    .on("click", function() { getSelectedGeo(); });

function getSelectedGeo() {
    selectedGeo = d3.select("input[name='geoType']:checked").node().value;
    console.log(selectedGeo);
}