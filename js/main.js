// variables to catch "initial" state
var view = "PC";
var selectedGeoID = null;
var selectedRegionFilter = "all"; // get the region/country user is filtering the change over time line chart with

var data,
    searchData;

var dispatch = d3.dispatch("load", "viewChange", "geoSelection", "regionFilterChange", "mapMouseover", "mapMouseout");

var COMMAFORMAT = d3.format(",.1f");

d3.queue()
    .defer(d3.csv, "data/index_data.csv")
    .defer(d3.json, "data/pcs_bboxes.json")
    .defer(d3.json, "data/regions_bboxes.json")
    .defer(d3.csv, "data/search_data.csv")
.await(function(error, index_data, pcs_bboxes, regions_bboxes, search_data) {

    if(error) throw error;

    index_data.forEach(function(d) {
        d.average_credit_use = +d.average_credit_use,
        d.date = d3.timeParse("%Y-%m-%d")(d.date),
        d.financial_vulnerability_index = +d.financial_vulnerability_index,
        d.share_claiming_social_benefits = +d.share_claiming_social_benefits,
        d.share_of_lowell_consumers_in_default = +d.share_of_lowell_consumers_in_default,
        d.share_using_alternative_financial_products = +d.share_using_alternative_financial_products,
        d.share_with_subprime_lending = +d.share_with_subprime_lending,
        d.share_without_emergency_savings = +d.share_without_emergency_savings,
        d.mapbox_id = +d.mapbox_id
    })

    var mostRecentYear = d3.max(index_data, function(d) { return d.year; });
    var mostRecentQuarter = d3.max(index_data.filter(function(d) { return d.year === mostRecentYear}),
        function(d) { return d.quarter; });

    dispatch.call("load", this, index_data, search_data, pcs_bboxes, regions_bboxes, mostRecentQuarter, mostRecentYear);
});

dispatch.on("load.hairChart", function(index_data, search_data, pcs_bboxes, regions_bboxes, mostRecentQuarter, mostRecentYear) {
    /*
     * Setup
     */
    const isMobile = false; // need to shift this later

    const aspectWidth = isMobile ? 3 : 6;
    const aspectHeight = isMobile ? 2 : 4;

    const width = d3.select("#hairChart").node().getBoundingClientRect().width;

    const margins = {
        top: 10,
        right: 20,
        bottom: 40,
        left: 20
    };

    const ticksX = 10;
    const ticksY = 5;
    const roundTicksFactor = 4;

    // Mobile
    if (isMobile) {
        ticksX = 5;
        ticksY = 5;
        margins['right'] = 25;
    }

    // Calculate actual chart dimensions
    const chartWidth = width - margins['left'] - margins['right'];
    const chartHeight = Math.ceil((width * aspectHeight) / aspectWidth) - margins['top'] - margins['bottom'];

    // // Clear existing graphic (for redraw)
    // const containerElement = d3.select(config['container']);
    // containerElement.html('');

    // Set x-position of the tooltip now that we know the chart width
    d3.select("#hairChart .tooltip").style("left", chartWidth + margins['left'] + margins['right'] + "px");

    // Nest data
    const dataSeries = d3.nest()
        .key(function(d) { return d.geo_name; })
        .entries(index_data);

    // console.log(dataSeries.length);

    /*
     * Create D3 scale objects.
     */
    const xScale = d3.scaleTime()
        .domain(d3.extent(index_data.map(function(d) { return d.date; })))
        .range([ 0, chartWidth ]);
    // const xScale = d3.scalePoint()
    //     .domain(uniqueQuarters)
    //     .range([ 0, chartWidth ]);

    const yScale = d3.scaleLinear()
        .domain(d3.extent(index_data.filter(function(d) { return d.geo === view; }).map(function(d) { return d.financial_vulnerability_index; })))
        .range([chartHeight, 0]);

    // /*
    //  * Render y-axis title.
    //  */
    // const yAxisTitle = containerElement.append('div')
    //     .attr('class', 'axis-title')
    //     .text('Axis title here');

    /*
     * Create the root SVG element.
     */
    const chartElement = d3.select("#hairChart")
        .append('svg')
            .attr('width', chartWidth + margins['left'] + margins['right'])
            .attr('height', chartHeight + margins['top'] + margins['bottom'])
        .append('g')
            .attr('transform', 'translate(' + margins['left'] + ',' + margins['top'] + ')');

    /*
     * Create D3 axes.
     */
     // need to rethink best way to display quarters since d3 doesn't natively support them
    const xAxis = g => g
        .attr('transform', "translate(0," + chartHeight + ")")
        .call(d3.axisBottom(xScale)
            .tickSizeOuter(0)
            .tickFormat(quarterFormatterLong));

    const yAxis = g => g
        .call(d3.axisLeft(yScale)
            .ticks(ticksY)
            .tickSize(-chartWidth))
        .call(g => g.selectAll('.domain')
            .remove());

    /*
     * Render axes to chart.
     */
    chartElement.append('g')
        .attr('class', 'y axis')
        .call(yAxis);

    chartElement.append('g')
        .attr('class', 'x axis')
        .call(xAxis);

    d3.selectAll('#hairChart .x.axis .tick')._groups[0].forEach(function(tick, i){
        if(i === 0) {
            var selection = d3.select(tick)
            selection.append('text')
                .text('Q3')
                .attr('class', 'year-label')
                .attr('dy',3)
                .attr('y',30)
                .attr('fill','#000000')
        }
        if(i === 11) { // need to make this dynamic and always select the last tick
            var selection = d3.select(tick)
            selection.append('text')
                .text('Q2')
                .attr('class', 'year-label')
                .attr('dy',3)
                .attr('y',30)
                .attr('fill','#000000')
        }
    })

    /*
     * Render lines to chart.
     */
    const line = d3.line()
        .defined(d => !isNaN(d["financial_vulnerability_index"]))
        .curve(d3.curveLinear)
        .x(d => xScale(d["date"]))
        .y(d => yScale(d["financial_vulnerability_index"]));

    const lines = chartElement.selectAll('.line')
        .data(dataSeries)
        .enter()
        .append("path")
            .attr('class', function(d) { return "line " + d.values[0].geo + " " + d.values[0].geo_id; })
            .attr('d', function(d) { return line(d['values']); })
        .on('mouseover', function(d) { d3.selectAll("#hairChart .line").classed("highlighted", false);
                                       d3.select(this).classed('highlighted', true);
                                       var mostRecentQuarterData = d["values"].filter(function(d) { return d.year === mostRecentYear && d.quarter === mostRecentQuarter; })[0];
                                       populateTooltip(mostRecentQuarterData);
                                     })
        .on('mouseout', function() { d3.select(this).classed('highlighted', false);
                                     d3.select("#hairChart .tooltip").classed("hidden", true); });

    // add voronoi to make line selection easier

    /*
     * Hide all region lines on initial page load
     */
    d3.selectAll("#hairChart .line.region").classed("invisible", true);

    function populateTooltip(data) {
       d3.select("#hairChart .tooltip .score").text(data.financial_vulnerability_index);
       d3.select("#hairChart .tooltip .geoName").text(data.geo_name);
       d3.select("#hairChart .tooltip").style("top", yScale(data.financial_vulnerability_index) + "px");
       d3.select("#hairChart .tooltip").classed("hidden", false);

       // don't forget to add .moveToFront
    }

    dispatch.on("viewChange.hairChart", function(view) {
        // update line chart when user switches between PC and region view
        // this resets any region filter that was applied
        if(view === "PC") {
            // show region/country filter above chart and reset to show all regions/countries
            d3.select(".changeOverTime .filters").classed("invisible", false);
            d3.select("#regionCountryFilter").property("value", "all");

            d3.selectAll("#hairChart .line.PC").classed("invisible", false);
            d3.selectAll("#hairChart .line.Region").classed("invisible", true);
            d3.select(".changeOverTime .legendLabel").text("Parliamentary constituencies");
        }
        else {
            // hide region/country filter when on region view
            d3.select(".changeOverTime .filters").classed("invisible", true);

            d3.selectAll("#hairChart .line.Region").classed("invisible", false);
            d3.selectAll("#hairChart .line.PC").classed("invisible", true);
            d3.select(".changeOverTime .legendLabel").text("Regions/countries");
        }

        // update y-axis scale
        yScale.domain(d3.extent(index_data.filter(function(d) { return d.geo == view}).map(function(d) { return d.financial_vulnerability_index; }))).nice();

        // update y axis and position of lines
        d3.selectAll("#hairChart .y.axis")
            .transition()
            // .duration(3000)
            .call(d3.axisLeft(yScale).ticks(5).tickSize(-chartWidth))  // .ticks(5) is equal to ticksY - refactor later
            .call(function(g) { g.selectAll('.domain').remove(); });

        lines.transition()
            .attr("d", function(d) { return line(d["values"]); });

        // hide any tooltips that are visible and make sure no lines are highlighted
        d3.select("#hairChart .tooltip").classed("hidden", true);
        d3.selectAll("#hairChart .line").classed("highlighted", false);
    });

    dispatch.on("regionFilterChange.hairChart", function(selectedRegion) {
        // show only lines for PCs in selected region
        d3.selectAll("#hairChart .line")
            .classed("invisible", function(d) { return d["values"][0].country_or_region_id === selectedRegion ? false : true; });

        // update y-axis
        yScale.domain(d3.extent(index_data.filter(function(d) { return d.country_or_region_id === selectedRegion}).map(function(d) { return d.financial_vulnerability_index; }))).nice();

        // update y axis and position of lines
        d3.selectAll("#hairChart .y.axis")
            .transition()
            // .duration(3000)
            .call(d3.axisLeft(yScale).ticks(5).tickSize(-chartWidth))  // .ticks(5) is equal to ticksY - refactor later
            .call(function(g) { g.selectAll('.domain').remove(); });

        lines.transition()
            .attr("d", function(d) { return line(d["values"]); });

        // hide any tooltips
        d3.selectAll("#hairChart .tooltip").classed("hidden", true);
    });

    dispatch.on("geoSelection.hairChart", function(selected_geo_name, selected_geo_id) {
        // if user searched for a PC, show all PC lines if not already (i.e., override region filter and reset chart)
        if(view === "PC") {
            d3.selectAll("#hairChart .line.PC").classed("invisible", false);
            d3.select("#regionCountryFilter").property("value", "all");

             // update y-axis scale
            yScale.domain(d3.extent(index_data.filter(function(d) { return d.geo == "PC"}).map(function(d) { return d.financial_vulnerability_index; }))).nice();

            // update y axis and position of lines
            d3.selectAll("#hairChart .y.axis")
                .transition()
                // .duration(3000)
                .call(d3.axisLeft(yScale).ticks(5).tickSize(-chartWidth))  // .ticks(5) is equal to ticksY - refactor later
                .call(function(g) { g.selectAll('.domain').remove(); });

            lines.transition()
                .attr("d", function(d) { return line(d["values"]); });
        }

        // highlight line belonging to the PC or region that was searched for
        // also show the tooltip with that geo's name and latest quarter's index value
        d3.selectAll("#hairChart .line").classed("highlighted", false);
        d3.select("#hairChart .line." + selected_geo_id).classed("highlighted", true);

        var selected_geo_data = d3.select("#hairChart .line." + selected_geo_id).datum();
        var mostRecentQuarterData = selected_geo_data["values"].filter(function(d) { return d.year === mostRecentYear && d.quarter === mostRecentQuarter; })[0]
        populateTooltip(mostRecentQuarterData);
    });
});

dispatch.on("load.map", function(index_data, search_data, pcs_bboxes, regions_bboxes, mostRecentQuarter, mostRecentYear) {

    // Filter data to the most recent quarter of data
    // since we only need most recent data for this part of the tool
    var most_recent_qtr_data = index_data.filter(function(d) { return d.quarter === mostRecentQuarter && d.year === mostRecentYear; });

    initMap(most_recent_qtr_data);

    var data = makeData(most_recent_qtr_data, "National", "");

    var chartWidth = d3.select("#panelIndexChart").node().getBoundingClientRect().width;
    var margins = {
        top: 10,
        right: 12,
        bottom: 40,
        left: 5
    };

    var range = d3.extent(most_recent_qtr_data, function(d) { return d["financial_vulnerability_index"]; });
    makeStickChart("panelIndexChart", "financial_vulnerability_index", data, range, chartWidth, margins);

    populateComponentsPanel(data, "National");

    dispatch.on("viewChange.map", function(view) {
        // when the user switches to a new view, update the map to show that view and reset the charts to only show the UK average
        if(view === "PC") {
            map.setLayoutProperty("PC-fill", "visibility", "visible");
            map.setLayoutProperty("PC-borders", "visibility", "visible");
            map.setLayoutProperty("PC-hover-borders", "visibility", "visible");
            map.setLayoutProperty("Region-fill", "visibility", "none");
            map.setLayoutProperty("Region-borders", "visibility", "none");
            map.setLayoutProperty("Region-hover-borders", "visibility", "none");
        }
        else {
            map.setLayoutProperty("PC-fill", "visibility", "none");
            map.setLayoutProperty("PC-borders", "visibility", "none");
            map.setLayoutProperty("PC-hover-borders", "visibility", "none");
            map.setLayoutProperty("Region-fill", "visibility", "visible");
            map.setLayoutProperty("Region-borders", "visibility", "visible");
            map.setLayoutProperty("Region-hover-borders", "visibility", "visible");
        }

        // var data = most_recent_qtr_data.filter(function(d) { return d.geo === "National"; });
        var data = makeData(most_recent_qtr_data, "National", "");

        updateStickChart("panelIndexChart", "financial_vulnerability_index", data, chartWidth, margins);
        populateComponentsPanel(data, "National");
    });

    dispatch.on("geoSelection.map", function(selected_geo_name, selected_geo_id) {
        var bounds = (view === "PC") ? pcs_bboxes[selected_geo_id]["bounds"] : regions_bboxes[selected_geo_id]["bounds"];
        zoomIn(bounds);

        var data = makeData(most_recent_qtr_data, view, selected_geo_id);

        updateStickChart("panelIndexChart", "financial_vulnerability_index", data, chartWidth);
        populateComponentsPanel(data, view);
    });

    dispatch.on("mapMouseover.map", function(hovered_geo_id) {
        var data = makeData(most_recent_qtr_data, view, hovered_geo_id);

        updateStickChart("panelIndexChart", "financial_vulnerability_index", data, chartWidth);
        populateComponentsPanel(data, view);
    });

    dispatch.on("mapMouseout.map", function() {
        // if clicked_geo_id is not null (i.e., a geo was searched for or clicked on in the map),
        // populate the Financial Distress Index and Component Scores sections with that geo's info
        // otherwise, populate those parts with national data only
        if(selectedGeoID) {
            var data = makeData(most_recent_qtr_data, view, selectedGeoID);
            updateStickChart("panelIndexChart", "financial_vulnerability_index", data, chartWidth);
            populateComponentsPanel(data, view);
        }
        else {
            var data = makeData(most_recent_qtr_data, "National", "");
            updateStickChart("panelIndexChart", "financial_vulnerability_index", data, chartWidth, margins);
            populateComponentsPanel(data, "National");
        }
    })
});

dispatch.on("load.componentsCharts", function(index_data, search_data, pcs_bboxes, regions_bboxes, mostRecentQuarter, mostRecentYear) {
    // Chart setup - TODO: turn this into a config object
    const isMobile = false; // need to shift this later

    const aspectWidth = isMobile ? 3 : 6;
    const aspectHeight = isMobile ? 2 : 4;

    const width = 300;

    const margins = {
        top: 10,
        right: 12,
        bottom: 40,
        left: 25
    };

    const ticksX = 10;
    const ticksY = 5;
    const roundTicksFactor = 4;

    // Mobile
    if (isMobile) {
        ticksX = 5;
        ticksY = 5;
        margins['right'] = 25;
    }

    // Calculate actual chart dimensions
    const chartWidth = width - margins['left'] - margins['right'];
    const chartHeight = Math.ceil((width * aspectHeight) / aspectWidth) - margins['top'] - margins['bottom'];

    // Filter data to the series we need and then Nest
    var filteredData = makeData(index_data, "National", "");

    const dataSeries = d3.nest()
        .key(function(d) { return d.geo; })
        .entries(filteredData);

    makeLineChart("financialVulnerabilityIndexChart", "financial_vulnerability_index", dataSeries, chartWidth, chartHeight, margins, ticksY);
    makeLineChart("consumersDefaultChart", "share_of_lowell_consumers_in_default", dataSeries, chartWidth, chartHeight, margins, ticksY);
    makeLineChart("socialBenefitsChart", "share_claiming_social_benefits", dataSeries, chartWidth, chartHeight, margins, ticksY);
    makeLineChart("subprimeLendingChart", "share_with_subprime_lending", dataSeries, chartWidth, chartHeight, margins, ticksY);
    makeLineChart("creditUseChart", "average_credit_use", dataSeries, chartWidth, chartHeight, margins, ticksY);

    // For the stick chart, filter data down to just one quarter
    var stickChartData = filteredData.filter(function(d) { return d.quarter === mostRecentQuarter && d.year === mostRecentYear; });

    var rangeEmergencySavings = d3.extent(index_data, function(d) { return d["share_without_emergency_savings"]; });
    var rangeAltFinancialProducts = d3.extent(index_data, function(d) { return d["share_using_alternative_financial_products"]; });

    makeStickChart("emergencySavingsChart", "share_without_emergency_savings", stickChartData, rangeEmergencySavings, chartWidth, margins);
    makeStickChart("altFinancialProductsChart", "share_using_alternative_financial_products", stickChartData, rangeAltFinancialProducts, chartWidth, margins);

    populateLegend(stickChartData);

    dispatch.on("viewChange.componentsCharts", function(view) {
        // when the user switches to a new view, reset the charts to only show the UK average
        // var data = index_data.filter(function(d) { return d.geo === "National"; });
        var data = makeData(index_data, "National", "");

        var newDataSeries = d3.nest()
            .key(function(d) { return d.geo; })
            .entries(data);

        updateLineChart("financialVulnerabilityIndexChart", "financial_vulnerability_index", newDataSeries, chartWidth, chartHeight, margins, ticksY);
        updateLineChart("consumersDefaultChart", "share_of_lowell_consumers_in_default", newDataSeries, chartWidth, chartHeight, margins, ticksY);
        updateLineChart("socialBenefitsChart", "share_claiming_social_benefits", newDataSeries, chartWidth, chartHeight, margins, ticksY);
        updateLineChart("subprimeLendingChart", "share_with_subprime_lending", newDataSeries, chartWidth, chartHeight, margins, ticksY);
        updateLineChart("creditUseChart", "average_credit_use", newDataSeries, chartWidth, chartHeight, margins, ticksY);

        // subset data to most recent quarter for the stick charts
        var stickChartData = data.filter(function(d) { return d.quarter === mostRecentQuarter && d.year === mostRecentYear; });

        // update stick charts
        updateStickChart("emergencySavingsChart", "share_without_emergency_savings", stickChartData, chartWidth);
        updateStickChart("altFinancialProductsChart", "share_using_alternative_financial_products", stickChartData, chartWidth);

        populateLegend(stickChartData);

    });

    dispatch.on("geoSelection.componentsCharts", function(selected_geo_name, selected_geo_id) {
        // build dataset for selected geo
        // if on PC view, dataset should have national, PC and regional data
        // if on region view, dataset should have national and regional data
        var data = makeData(index_data, view, selected_geo_id);

        var newDataSeries = d3.nest()
            .key(function(d) { return d.geo; })
            .entries(data);

        // update line charts
        updateLineChart("financialVulnerabilityIndexChart", "financial_vulnerability_index", newDataSeries, chartWidth, chartHeight, ticksY);
        updateLineChart("consumersDefaultChart", "share_of_lowell_consumers_in_default", newDataSeries, chartWidth, chartHeight, ticksY);
        updateLineChart("socialBenefitsChart", "share_claiming_social_benefits", newDataSeries, chartWidth, chartHeight, ticksY);
        updateLineChart("subprimeLendingChart", "share_with_subprime_lending", newDataSeries, chartWidth, chartHeight, ticksY);
        updateLineChart("creditUseChart", "average_credit_use", newDataSeries, chartWidth, chartHeight, ticksY);

        // subset data to most recent quarter for the stick charts
        var stickChartData = data.filter(function(d) { return d.quarter === mostRecentQuarter && d.year === mostRecentYear; });

        // update stick charts
        updateStickChart("emergencySavingsChart", "share_without_emergency_savings", stickChartData, chartWidth);
        updateStickChart("altFinancialProductsChart", "share_using_alternative_financial_products", stickChartData, chartWidth);

        populateLegend(stickChartData);
    });
});

function makeData(full_dataset, view, geo_id) {
    var data = [];
    var nationalData = full_dataset.filter(function(d) { return d.geo === "National"; });

    if(view === "PC") {
        var pcData = full_dataset.filter(function(d) { return d.geo_id === geo_id; });
        var region_id = pcData[0].country_or_region_id;
        var regionData = full_dataset.filter(function(d) { return d.geo_id === region_id; });
        return data.concat(pcData, regionData, nationalData);
    }
    else if(view === "Region") {
        var regionData = full_dataset.filter(function(d) { return d.geo_id === geo_id; });
        return data.concat(regionData, nationalData);
    }

    return nationalData;
}

function makeLineChart(elementID, metric, data, chartWidth, chartHeight, margins, ticksY) {
    /*
     * Create D3 scale objects.
     */
    const xScale = d3.scaleTime()
        .domain(d3.extent(data[0]['values'].map(function(d) { return d.date; })))
        .range([ 0, chartWidth ]);

    const yScale = d3.scaleLinear()
        .domain([0, 100])
        .range([chartHeight, 0]);

    /*
     * Create the root SVG element.
     */
    const chartElement = d3.select("#" + elementID)
        .append('svg')
            .attr('width', chartWidth + margins['left'] + margins['right'])
            .attr('height', chartHeight + margins['top'] + margins['bottom'])
        .append('g')
            .attr('transform', 'translate(' + margins['left'] + ',' + margins['top'] + ')');

    /*
     * Create D3 axes.
     */
     const yAxis = g => g
        .call(d3.axisLeft(yScale)
            .ticks(ticksY)
            .tickSize(-chartWidth))
        .call(g => g.selectAll('.domain')
            .remove());
     // need to rethink best way to display quarters since d3 doesn't natively support them
    const xAxis = g => g
        .attr('transform', "translate(0," + chartHeight + ")")
        .call(d3.axisBottom(xScale)
            .tickSizeOuter(0)
            .tickFormat(quarterFormatterShort));

    /*
     * Render axes to chart.
     */
    chartElement.append('g')
        .attr('class', 'y axis')
        .call(yAxis);

    chartElement.append('g')
        .attr('class', 'x axis')
        .call(xAxis);

    d3.selectAll('#' + elementID + ' .x.axis .tick')._groups[0].forEach(function(tick, i){
        if(i === 0) {
            var selection = d3.select(tick)
            selection.append('text')
                .text('Q3')
                .attr('class', 'year-label')
                .attr('dy',3)
                .attr('y',30)
                .attr('fill','#000000')
        }
        if(i === 11) { // need to make this dynamic and always select the last tick
            var selection = d3.select(tick)
            selection.append('text')
                .text('Q2')
                .attr('class', 'year-label')
                .attr('dy',3)
                .attr('y',30)
                .attr('fill','#000000')
        }
    })

    /*
     * Render lines to chart.
     */
    const line = d3.line()
        .defined(d => !isNaN(d[metric]))
        .curve(d3.curveLinear)
        .x(d => xScale(d["date"]))
        .y(d => yScale(d[metric]));

    const lines = chartElement.selectAll('.line')
        .data(data, function(d) { return d.key; })
        .enter()
        .append("path")
            .attr('class', function(d) { return "line " + d.key; })
            .attr('d', function(d) { return line(d['values']); });
        // .append("text")
        //     .attr("x", width)
        //     .attr("y", yScale(50))
        //     .text(function(d) { return d.key; });
}

function updateLineChart(elementID, metric, data, chartWidth, chartHeight, ticksY) {
    const xScale = d3.scaleTime()
        .domain(d3.extent(data[0]['values'].map(function(d) { return d.date; })))
        .range([ 0, chartWidth ]);

    const yScale = d3.scaleLinear()
        .domain([0, 100])
        .range([chartHeight, 0]);

    const line = d3.line()
        .defined(d => !isNaN(d[metric]))
        .curve(d3.curveLinear)
        .x(d => xScale(d["date"]))
        .y(d => yScale(d[metric]));

    var lines = d3.select("#" + elementID + " svg g")
        .selectAll(".line")
        .data(data, function(d) { return d.key; });

    lines.exit().remove();

    lines.enter()
        .append("path")
        .attr("class", function(d) { return "line " + d.key; })
        .merge(lines)
        .transition()
        .attr("d", function(d) { return line(d.values); });
        // .attrTween("d", function(d) {
        //     var previous = d3.select(this).attr("d");
        //     var current = line(d.values);
        //     return d3.interpolatePath(previous, current);
        // });
}

function makeStickChart(elementID, metric, data, range, chartWidth, margins) {

    // make the top "table" of numbers and place names
    var table = d3.select("#" + elementID)
        .append("div")
        .attr("class", "container");

    var columns = table.selectAll(".column")
        .data(data)
        .enter()
        .append("div")
            .attr("class", function(d) { return "column " + d.geo; });

    columns.append("div")
        .attr("class", "number")
            .text(function(d) { return metric === "financial_vulnerability_index" ? COMMAFORMAT(d[metric]) : COMMAFORMAT(d[metric]) + "%"; });

    columns.append("div")
        .attr("class", "geoName")
            .text(function(d) { return d.geo_name; });

    // make stick chart
    var chartHeight = 15;

    const xScale = d3.scaleLinear()
        .domain([0, 100])
        .range([0, chartWidth]);

    var chartElement = d3.select("#" + elementID)
        .append("svg")
            .attr('width', chartWidth + margins['left'] + margins['right'])
            .attr('height', chartHeight + margins['top'] + margins['bottom'])
        .append('g')
            .attr('transform', 'translate(' + margins['left'] + ',' + margins['top'] + ')');

    const xAxis = g => g
        .attr('transform', "translate(0," + chartHeight + ")")
        .call(d3.axisBottom(xScale)
            .ticks(5)
            .tickSizeOuter(0));

    // Shade in range of scores on the x-axis
    var scoreRange = chartElement.append('g')
        .attr('class', 'scoreRange')
        .attr('transform', 'translate(0,' + chartHeight + ')');

    scoreRange.append('rect')
        .attr('x', xScale(range[0]))
        .attr('y', 0)
        .attr('width', xScale(range[1] - range[0]))
        .attr('height', 23);

    scoreRange.append('text')
        .attr('x', Math.max(53, ( xScale(range[0]) + xScale(range[1]) ) / 2 ))
        .attr('y', chartHeight + 25)
        .text('Range of Scores');

    /*
     * Render axes to chart.
     */
    chartElement.append('g')
        .attr('class', 'x axis')
        .call(xAxis);

    var sticks = chartElement.selectAll(".stick")
        .data(data, function(d) { return d.geo; })
        .enter()
        .append("line")
            .attr("class", function(d) { return "stick " + d.geo ; })
            .attr("x1", function(d) { return xScale(d[metric]); })
            .attr("x2", function(d) { return xScale(d[metric]); })
            .attr("y1", 0)
            .attr("y2", chartHeight);
}

function updateStickChart(elementID, metric, data, chartWidth) {

    var columns = d3.select("#" + elementID + " .container")
        .selectAll(".column")
        .data(data);

    columns.exit().remove();

    var columnsEnter = columns.enter()
        .append("div")
            // .attr("class", function(d) { return "column " + d.geo; });

    columnsEnter.append("div")
        .attr("class", "number");

    columnsEnter.append("div")
        .attr("class", "geoName");

    columnsEnter = columnsEnter.merge(columns)
        .attr("class", function(d) { return "column " + d.geo; });

    columnsEnter.select(".number")
        .text(function(d) { return metric === "financial_vulnerability_index" ? COMMAFORMAT(d[metric]) : COMMAFORMAT(d[metric]) + "%"; });

    columnsEnter.select(".geoName")
        .text(function(d) { return d.geo_name; });

    const xScale = d3.scaleLinear()
        .domain([0, 100])
        .range([0, chartWidth]);

    var sticks = d3.select("#" + elementID + " svg g")
        .selectAll(".stick")
        .data(data, function(d) { return d.geo; });

    sticks.exit().remove();

    sticks.enter()
        .append("line")
            .attr("class", function(d) { return "stick " + d.geo; })
        .merge(sticks)
        .transition()
            .attr("class", function(d) { return "stick " + d.geo ; })
            .attr("x1", function(d) { return xScale(d[metric]); })
            .attr("x2", function(d) { return xScale(d[metric]); })
            .attr("y1", 0)
            .attr("y2", 15);
}

function populateLegend(data) {
    // populate the legend that appears below the Financial Vulnerability Index chart in the Go Deeper section

    var legend = d3.select(".components .legend");

    if(data.length === 1) {
        legend.select(".legendEntry.pc").classed("hidden", true);
        legend.select(".legendEntry.region").classed("hidden", true);
    }
    else if(data.length === 2) {
        legend.select(".legendEntry.pc").classed("hidden", true);
        legend.select(".legendEntry.region").classed("hidden", false);

        legend.select(".legendLabel.region").text(data.filter(function(d) { return d.geo === "Region"; })[0]["geo_name"]);
    }
    else {
        legend.select(".legendEntry.pc").classed("hidden", false);
        legend.select(".legendEntry.region").classed("hidden", false);

        legend.select(".legendLabel.pc").text(data.filter(function(d) { return d.geo === "PC"; })[0]["geo_name"]);
        legend.select(".legendLabel.region").text(data.filter(function(d) { return d.geo === "Region"; })[0]["geo_name"]);
    }
}

function populateComponentsPanel(data, view) {
    // show or hide bars based on which geo is selected
    if(data.length === 1) {
        d3.selectAll(".componentScores .chart .pc").style("display", "none");
        d3.selectAll(".componentScores .chart .region").style("display", "none");
    }
    else if(data.length === 2) {
        d3.selectAll(".componentScores .chart .pc").style("display", "none");
        d3.selectAll(".componentScores .chart .region").style("display", "block");
    }
    else {
        d3.selectAll(".componentScores .chart .pc").style("display", "block");
        d3.selectAll(".componentScores .chart .region").style("display", "block");
    }

    var metricElementMap = {
        inDefault: "share_of_lowell_consumers_in_default",
        socialBenefits: "share_claiming_social_benefits",
        subprimeLending: "share_with_subprime_lending",
        creditUse: "average_credit_use",
        emergencySavings: "share_without_emergency_savings",
        altFinancialProducts: "share_using_alternative_financial_products"
    }

    Object.keys(metricElementMap).forEach(function(element) {
        // the numbers in the table are for the most specific geography selected
        d3.select("." + element + " .number")
            .attr("class", "number " + view + "Number")
            .text(COMMAFORMAT(data.filter(function(d) { return d.geo === view; })[0][metricElementMap[element]]) + "%");

        // adjust length of bars
        d3.select("." + element + " .national")
            .style("width", data.filter(function(d) { return d.geo === "National"; })[0][metricElementMap[element]] + "%");

        if(data.length === 3) {
            d3.select("." + element + " .pc")
                .style("width", data.filter(function(d) { return d.geo === "PC"; })[0][metricElementMap[element]] + "%");
        }

        if(data.length >= 2) {
            d3.select("." + element + " .region")
                .style("width", data.filter(function(d) { return d.geo === "Region"; })[0][metricElementMap[element]] + "%");
        }
    });
}

function initMap(index_data){

    mapboxgl.accessToken = 'pk.eyJ1IjoidXJiYW5pbnN0aXR1dGUiLCJhIjoiTEJUbmNDcyJ9.mbuZTy4hI_PWXw3C3UFbDQ';

    map = new mapboxgl.Map({
        attributionControl: false,
        container: 'map',
        style: 'mapbox://styles/urbaninstitute/ckjkfrl3g1jqk19mee5uwvubf',
        center: [-2.5, 54.356],
        zoom: 4.5,
        maxZoom: 11,
        minZoom: 3.5
    });

    var hoverGeoID = null, // track which geo is mousedover
        clickedGeoID = null,
        hoverGeoID_orig,
        clickedGeoID_orig;

    map.on('load', function() {

        // make the tract outlines in the tract-hover-strokes layer transparent
        // will modify this so that the tract the user has hovered over is outlined
        map.setPaintProperty(
            'PC-hover-borders',
            'line-opacity',
            [
                'case',
                ['boolean', ['feature-state', 'highlight'], false],
                1,
                0
            ]
        );

        map.setPaintProperty(
            'Region-hover-borders',
            'line-opacity',
            [
                'case',
                ['boolean', ['feature-state', 'highlight'], false],
                1,
                0
            ]
        );

        // disable map rotation using right click + drag
        map.dragRotate.disable();

        // disable map rotation using touch rotation gesture
        map.touchZoomRotate.disableRotation();

        // on tablet and phone screens, disable map zoom when using scroll
        if(d3.select(".container").node().getBoundingClientRect().width < 968) {
            map.scrollZoom.disable();
        }

        // hover behavior adapted from: https://docs.mapbox.com/help/tutorials/create-interactive-hover-effects-with-mapbox-gl-js/
        // also a good resource: https://blog.mapbox.com/going-live-with-electoral-maps-a-guide-to-feature-state-b520e91a22d
        map.on('mousemove', 'PC-fill', function(e) { // detect mousemove on the fill layer instead of stroke layer so correct tract is highlighted

            map.getCanvas().style.cursor = 'pointer';

            // Check whether features exist
            if (e.features.length > 0) {

                // If geoID for the hovered feature is not null,
                // use removeFeatureState to reset to the default behavior
                if (hoverGeoID) {
                    map.removeFeatureState({
                        source: 'composite',  // can find what the source and sourceLayer are from console logging e.features[0]["layer"]
                        sourceLayer: 'pcsid',
                        id: hoverGeoID
                    });
                }

                hoverGeoID = e.features[0]["id"]; // this is the Mapbox numeric id
                hoverGeoID_orig = e.features[0]["properties"]["geo_id"];

                // When the mouse moves over the tract-hover-strokes layer, update the
                // feature state for the feature under the mouse
                map.setFeatureState({
                    source: 'composite',
                    sourceLayer: 'pcsid',
                    id: hoverGeoID
                },
                {
                    highlight: true
                });

                dispatch.call("mapMouseover", this, hoverGeoID_orig);

                // if a geo has been clicked on, make sure it is still highlighted
                if(clickedGeoID) {
                    map.setFeatureState({
                        source: 'composite',
                        sourceLayer: 'pcsid',
                        id: clickedGeoID
                    }, {
                        highlight: true
                    });
                }
            }

        });

        map.on("mouseleave", "PC-fill", function() {

            if (hoverGeoID) {
                map.setFeatureState({
                    source: 'composite',
                    sourceLayer: 'pcsid',
                    id: hoverGeoID
                }, {
                    highlight: false
                });
            }

            hoverGeoID = null;

            // if a geo has been clicked on, keep it highlighted
            if(clickedGeoID) {
                map.setFeatureState({
                    source: 'composite',
                    sourceLayer: 'pcsid',
                    id: clickedGeoID
                }, {
                    highlight: true
                });
            }

            dispatch.call("mapMouseout", this);

            // Reset the cursor style
            map.getCanvas().style.cursor = '';
        });

        map.on("click", "PC-fill", function(e) {

            if(e.features.length > 0) {
                // stop highlighting any previously clicked on tracts
                if (clickedGeoID) {
                    map.removeFeatureState({
                        source: 'composite',
                        sourceLayer: 'pcsid',
                        id: clickedGeoID
                    });
                }

                clickedGeoID = e.features[0].id; // this is the Mapbox numeric id
                clickedGeoID_orig = e.features[0].properties["geo_id"];
                clickedGeoName = e.features[0].properties["PCON17NM"];
                selectedGeoID = clickedGeoID_orig;

                map.setFeatureState({
                    source: 'composite',
                    sourceLayer: 'pcsid',
                    id: clickedGeoID
                },
                {
                    highlight: true
                });

                dispatch.call("geoSelection", this, clickedGeoName, clickedGeoID_orig);
            }
        });

        map.on('mousemove', 'Region-fill', function(e) {

            map.getCanvas().style.cursor = 'pointer';

            // Check whether features exist
            if (e.features.length > 0) {

                // If geoID for the hovered feature is not null,
                // use removeFeatureState to reset to the default behavior
                if (hoverGeoID) {
                    map.removeFeatureState({
                        source: 'composite',  // can find what the source and sourceLayer are from console logging e.features[0]["layer"]
                        sourceLayer: 'regionsid',
                        id: hoverGeoID
                    });
                }

                hoverGeoID = e.features[0]["id"]; // this is the Mapbox numeric id
                hoverGeoID_orig = e.features[0]["properties"]["geo_id"];

                // When the mouse moves over the tract-hover-strokes layer, update the
                // feature state for the feature under the mouse
                map.setFeatureState({
                    source: 'composite',
                    sourceLayer: 'regionsid',
                    id: hoverGeoID
                },
                {
                    highlight: true
                });

                dispatch.call("mapMouseover", this, hoverGeoID_orig);

                // if a geo has been clicked on, make sure it is still highlighted
                if(clickedGeoID) {
                    map.setFeatureState({
                        source: 'composite',
                        sourceLayer: 'regionsid',
                        id: clickedGeoID
                    }, {
                        highlight: true
                    });
                }
            }

        });

        map.on("mouseleave", "Region-fill", function() {

            if (hoverGeoID) {
                map.setFeatureState({
                    source: 'composite',
                    sourceLayer: 'regionsid',
                    id: hoverGeoID
                }, {
                    highlight: false
                });
            }

            hoverGeoID = null;

            // if a geo has been clicked on, keep it highlighted
            if(clickedGeoID) {
                map.setFeatureState({
                    source: 'composite',
                    sourceLayer: 'regionsid',
                    id: clickedGeoID
                }, {
                    highlight: true
                });
            }

            dispatch.call("mapMouseout", this);

            // Reset the cursor style
            map.getCanvas().style.cursor = '';
        });

        map.on("click", "Region-fill", function(e) {

            if(e.features.length > 0) {
                // stop highlighting any previously clicked on tracts
                if (clickedGeoID) {
                    map.removeFeatureState({
                        source: 'composite',
                        sourceLayer: 'regionsid',
                        id: clickedGeoID
                    });
                }

                clickedGeoID = e.features[0].id; // this is the Mapbox numeric id
                clickedGeoID_orig = e.features[0].properties["geo_id"];
                clickedGeoName = e.features[0].properties["nuts118nm"];
                selectedGeoID = clickedGeoID_orig;

                map.setFeatureState({
                    source: 'composite',
                    sourceLayer: 'regionsid',
                    id: clickedGeoID
                },
                {
                    highlight: true
                });

                dispatch.call("geoSelection", this, clickedGeoName, clickedGeoID_orig);
            }
        });
    });

    map.addControl(new mapboxgl.NavigationControl({"showCompass": false}), "bottom-right");

    dispatch.on("viewChange.mapboxMap", function(view) {
        // remove any highlighted PCs or regions when the view is changed
        map.setFeatureState({
            source: 'composite',
            sourceLayer: 'pcsid',
            id: clickedGeoID
        }, {
            highlight: false
        });

        map.setFeatureState({
            source: 'composite',
            sourceLayer: 'regionsid',
            id: clickedGeoID
        }, {
            highlight: false
        });
    });

    dispatch.on("geoSelection.mapboxMap", function(selected_geo_name, selected_geo_id) {
        // first clear any previous highlighting (i.e., if the user clicked on the map)
        map.setFeatureState({
            source: 'composite',
            sourceLayer: 'pcsid',
            id: clickedGeoID
        }, {
            highlight: false
        });

        map.setFeatureState({
            source: 'composite',
            sourceLayer: 'regionsid',
            id: clickedGeoID
        }, {
            highlight: false
        });

        // get the mapbox ID for the selected geo
        clickedGeoID = index_data.filter(function(d) { return d.geo_id === selected_geo_id})[0]["mapbox_id"];

        if(view === "PC") {
            map.setFeatureState({
                source: 'composite',
                sourceLayer: 'pcsid',
                id: clickedGeoID
            }, {
                highlight: true
            });
        }
        else {
            map.setFeatureState({
                source: 'composite',
                sourceLayer: 'regionsid',
                id: clickedGeoID
            }, {
                highlight: true
            });
        }
    });
}

function zoomIn(bounds) {
    map.fitBounds(
        bounds,
        {
            "padding": 20,
            "duration": 900,
            "essential": true, // If true, then the animation is considered essential and will not be affected by prefers-reduced-motion .
        }
    );
}

// EVENT LISTENERS
d3.selectAll("input[name='geoType']")
    .on("click", function() { view = getSelectedView();
                              selectedGeoID = null;
                              dispatch.call("viewChange", this, view); });

d3.select("#regionCountryFilter")
    .on("change", function() { dispatch.call("regionFilterChange", this, d3.select(this).property("value")); });


d3.select("#locationSearch").on("click", function() { $("#locationSearch").val(""); });

dispatch.on("load.searchbox", function(index_data, search_data, mostRecentQuarter) {
    $("#locationSearch").autocomplete({
        source: search_data,
        search: function() {
            if(this.value.length < 4) {  // only display options after at least 4 characters are typed because this dataset is really big
                return false;
            }
        },
        select: function( event, ui ) {
            console.log(ui.item);
            $("#locationSearch").val(ui.item.label);   // need this so when user clicks on a county name instead of hitting the enter key, the full name is captured (otherwise, only typed letters will get captured)

            selectedGeoID = ui.item.id;
            dispatch.call("geoSelection", this, ui.item.label, selectedGeoID);
        },
        // open: function( event, ui ) {
        //     d3.select("#magnifyGlass").style("visibility", "hidden");
        // },
        close: function( event, ui ) {
            // $("#countySearch").val("");
        //     d3.select("#magnifyGlass").style("visibility", "visible");
        }
    });

    dispatch.on("viewChange.searchbox", function(view) {
        // clear searchbox contents
        $("#locationSearch").val("");

        // update placeholder text

        // update search data
        $("#locationSearch").autocomplete({
            source: search_data.filter(function(d) { return d.search_level === view; })
        });
    });

    dispatch.on("geoSelection.searchbox", function(selected_geo_name, selected_geo_id) {
        $("#locationSearch").val(selected_geo_name);
    });
});

function getSelectedView() {
    return d3.select("input[name='geoType']:checked").node().value;
}

var quarterFormatterLong = function(date, i) {
    // display the year for Q1, nothing for all other quarters except the first and last quarters of data
    // code from here: https://stackoverflow.com/questions/26921414/d3js-x-axis-data-by-quarter-sub-grouped-by-year
    // var date2 = new Date();
    var year = date.getFullYear(),
        month = date.getMonth(),
        quarter = Math.ceil(month / 3 ) + 1;

    if(quarter === 1 | i === 0 || i === 11) {
        // if(!isMobile) return year;
        return year;
    }
}

var quarterFormatterShort = function(date, i) {
    // display the year for Q1, nothing for all other quarters except the first and last quarters of data
    // code from here: https://stackoverflow.com/questions/26921414/d3js-x-axis-data-by-quarter-sub-grouped-by-year
    // var date2 = new Date();
    var year = date.getFullYear(),
        month = date.getMonth(),
        quarter = Math.ceil(month / 3 ) + 1;

    if(quarter === 1 | i === 0 || i === 11) {
        // if(!isMobile) return year;
        return "'" + year % 2000;
    }
}
