// variables to catch "initial" state
var view = "PCs";
var selectedGeo = "PC";
var selectedRegionFilter = "all"; // get the region/country user is filtering the change over time line chart with

var data;
var yScale_changeOverTime;
var xScale_time;

d3.queue()
    .defer(d3.csv, "data/index_data.csv")
    // .defer(d3.json, "data/coc_bboxes.json")
    // .defer(d3.csv, "data/geos.csv")
.await(function(error, index_data/*, coc_bboxes, geos*/) {

    if(error) throw error;

    // countyJson = county_bboxes;
    // cocJson = coc_bboxes;

    index_data.forEach(function(d) {
        d.average_credit_use = +d.average_credit_use,
        d.date = d3.timeParse("%Y-%m-%d")(d.date),
        d.financial_vulnerability_index = +d.financial_vulnerability_index,
        d.share_claiming_social_benefits = +d.share_claiming_social_benefits,
        d.share_of_lowell_consumers_in_default = +d.share_of_lowell_consumers_in_default,
        d.share_using_alternative_financial_products = +d.share_using_alternative_financial_products,
        d.share_with_subprime_lending = +d.share_with_subprime_lending,
        d.share_without_emergency_savings = +d.share_without_emergency_savings
    })

    // console.log(index_data);
    data = index_data;

    makeLineChart(index_data);

});

function makeLineChart(data) {
    /*
     * Setup
     */
    const isMobile = false; // need to shift this later

    const aspectWidth = isMobile ? 3 : 6;
    const aspectHeight = isMobile ? 2 : 4;

    const width = d3.select("#lineChart").node().getBoundingClientRect().width;

    const margins = {
        top: 10,
        right: 12,
        bottom: 20,
        left: 20
    };

    const ticksX = 10;
    const ticksY = 5;
    const roundTicksFactor = 4;

    // Mobile
    if (isMobile) {
        ticksX = 5;
        ticksY = 5;
        margins['right'] = 25;
    }

    // Calculate actual chart dimensions
    const chartWidth = width - margins['left'] - margins['right'];
    const chartHeight = Math.ceil((width * aspectHeight) / aspectWidth) - margins['top'] - margins['bottom'];

    // // Clear existing graphic (for redraw)
    // const containerElement = d3.select(config['container']);
    // containerElement.html('');

    // Set x-position of the tooltip now that we know the chart width
    d3.select("#lineChart .tooltip").style("left", chartWidth + margins['left'] + margins['right'] + "px");

    // Nest data
    const dataSeries = d3.nest()
        .key(function(d) { return d.geo_name; })
        .entries(data);

    console.log(dataSeries);

    /*
     * Create D3 scale objects.
     */
    xScale_time = d3.scaleTime()
        .domain(d3.extent(data.map(function(d) { return d.date; })))
        .range([ 0, chartWidth ]);

    yScale_changeOverTime = d3.scaleLinear()
        .domain(d3.extent(data.filter(function(d) { return d.geo === selectedGeo; }).map(function(d) { return d.financial_vulnerability_index; })))
        .range([chartHeight, 0]);

    // /*
    //  * Render y-axis title.
    //  */
    // const yAxisTitle = containerElement.append('div')
    //     .attr('class', 'axis-title')
    //     .text('Axis title here');

    /*
     * Create the root SVG element.
     */
    const chartElement = d3.select("#lineChart")
        .append('svg')
            .attr('width', chartWidth + margins['left'] + margins['right'])
            .attr('height', chartHeight + margins['top'] + margins['bottom'])
        .append('g')
            .attr('transform', 'translate(' + margins['left'] + ',' + margins['top'] + ')');

    /*
     * Create D3 axes.
     */
     // need to rethink best way to display quarters since d3 doesn't natively support them
    const xAxis = g => g
        .attr('transform', "translate(0," + chartHeight + ")")
        .call(d3.axisBottom(xScale_time)
            // .ticks(d3.timeYear)  // pass in a number or time interval that makes more sense for your data
            // .tickFormat((t, i) => (i % 2 !== 0) ? " " : d3.timeFormat('%Y')(t))  // label only every other tick mark to avoid overlapping label
            .tickSizeOuter(0));
        // .call(g => g.selectAll('.domain').remove());

    const yAxis = g => g
        .call(d3.axisLeft(yScale_changeOverTime)
            .ticks(ticksY)
            .tickSize(-chartWidth))
        .call(g => g.selectAll('.domain')
            .remove());

    /*
     * Render axes to chart.
     */
    chartElement.append('g')
        .attr('class', 'x axis')
        .call(xAxis);

    chartElement.append('g')
        .attr('class', 'y axis')
        .call(yAxis);

    /*
     * Render lines to chart.
     */
    const line = d3.line()
        .defined(d => !isNaN(d["financial_vulnerability_index"]))
        .curve(d3.curveLinear)
        .x(d => xScale_time(d["date"]))
        .y(d => yScale_changeOverTime(d["financial_vulnerability_index"]));

    const lines = chartElement.selectAll('path')
        .data(dataSeries)
        .enter()
        .append("path")
            .attr('class', function(d) { return "line " + d.values[0].geo + " " + d.values[0].geo_id; })
            .attr('d', function(d) { return line(d['values']); })
        .on('mouseover', function(d) { d3.select(this).classed('highlighted', true);
                                       var mostRecentQuarterData = d["values"].filter(function(d) { return d.quarter === "Q2" && d.year === "2020"; })[0];
                                       d3.select("#lineChart .tooltip .score").text(mostRecentQuarterData.financial_vulnerability_index);
                                       d3.select("#lineChart .tooltip .geoName").text(mostRecentQuarterData.geo_name);
                                       d3.select("#lineChart .tooltip").style("top", yScale_changeOverTime(mostRecentQuarterData.financial_vulnerability_index) + "px");
                                       d3.select("#lineChart .tooltip").classed("hidden", false);
                                     })  // don't forget to add .moveToFront
        .on('mouseout', function() { d3.select(this).classed('highlighted', false);
                                     d3.select("#lineChart .tooltip").classed("hidden", true); });

    // add voronoi to make line selection easier

    /*
     * Hide all region lines on initial page load
     */
    d3.selectAll("#lineChart .line.region").classed("invisible", true);
}

// EVENT LISTENERS
d3.selectAll("input[name='geoType']")
    .on("click", function() { switchGeo(); });

// detect when user has used search box

d3.select("#regionCountryFilter")
    .on("change", function() { selectedRegionFilter = d3.select(this).property("value");
                               updateLineChart(); });

function switchGeo() {
    selectedGeo = getSelectedGeo();

    /* switch chart and map view */
    updateLineChart();

    // show or hide the region/country filter above the change over time line chart
    // based on which geo is selected
    if(selectedGeo === "PC") {
        d3.select("#regionCountryFilter").classed("invisible", false);
    }
    else {
        d3.select("#regionCountryFilter").classed("invisible", true);
    }
}

function getSelectedGeo() {
    return d3.select("input[name='geoType']:checked").node().value;
}

function updateLineChart() {
    var chartWidth = d3.select("#lineChart").node().getBoundingClientRect().width;

    // hide/show lines based on geography selected
    if(selectedGeo == "PC") {
        d3.selectAll("#lineChart .line.PC").classed("invisible", false);
        d3.selectAll("#lineChart .line.region").classed("invisible", true);

        // if in PC mode and a specific region/country has been selected, hide/show lines based on whether
        // the PC is in the selected region/country
        if(selectedRegionFilter !== "all") {
            d3.selectAll("#lineChart .line")
                .classed("invisible", function(d) { return d["values"][0].country_or_region_id === selectedRegionFilter ? false : true; });
        }
    }
    else if(selectedGeo == "region") {
        d3.selectAll("#lineChart .line.region").classed("invisible", false);
        d3.selectAll("#lineChart .line.PC").classed("invisible", true);
    }

    // update y-axis scale based on what lines are being shown on the chart
    if(selectedRegionFilter !== "all" && selectedGeo === "PC") {
        yScale_changeOverTime.domain(d3.extent(data.filter(function(d) { return d.country_or_region_id === selectedRegionFilter}).map(function(d) { return d.financial_vulnerability_index; }))).nice();
    }
    else {
        yScale_changeOverTime.domain(d3.extent(data.filter(function(d) { return d.geo == selectedGeo}).map(function(d) { return d.financial_vulnerability_index; }))).nice();
    }

    // update y axis and position of lines
    d3.selectAll("#lineChart .y.axis")
        .transition()
        // .duration(3000)
        .call(d3.axisLeft(yScale_changeOverTime).ticks(5).tickSize(-chartWidth))  // .ticks(5) is equal to ticksY - refactor later
        .call(function(g) { g.selectAll('.domain').remove(); });

    var line = d3.line()
        .defined(d => !isNaN(d["financial_vulnerability_index"]))
        .curve(d3.curveLinear)
        .x(d => xScale_time(d["date"]))
        .y(d => yScale_changeOverTime(d["financial_vulnerability_index"]));

    d3.selectAll("#lineChart .line")
        .transition()
        .attr("d", function(d) { return line(d["values"]); });
}