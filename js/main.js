// variables to catch "initial" state
var view = "PC";
var selectedGeoID = null;
var mouseG;

var data,
searchData,
previousPeriodYear,
previousQuarter,
numberOfQuarters;


var widthWindow = window.innerWidth;

if(widthWindow > 649) {
  document.getElementById("map").style.height = '576px';
} else {
  document.getElementById("map").style.height = '65vh';
}

var dispatch = d3.dispatch("load", "viewChange", "geoSelection", "mapMouseover", "mapMouseout", "resize");

var COMMAFORMAT = d3.format(",.1f");

// POLYFILL FOR IE which doesn't support .forEach() on node lists
if (typeof Array.prototype.forEach != 'function') {
  Array.prototype.forEach = function (callback) {
    for (var i = 0; i < this.length; i++) {
      callback.apply(this, [this[i], i, this]);
    }
  };
}

if (window.NodeList && !NodeList.prototype.forEach) {
  NodeList.prototype.forEach = Array.prototype.forEach;
}

d3.queue()
.defer(d3.csv, "data/index_data.csv")
.defer(d3.json, "data/pcs_bboxes.json")
.defer(d3.json, "data/regions_bboxes.json")
.defer(d3.csv, "data/search_data_v2.csv")
.await(function(error, index_data, pcs_bboxes, regions_bboxes, search_data) {

  if(error) throw error;
  //if the variable names were different in the .xls, you could just change them here
  index_data.forEach(function(d) {
    d.average_credit_use = +d.average_credit_use_among_lowell_consumers,
    d.date = d3.timeParse("%Y-%m-%d")(d.date),
    d.financial_vulnerability_index = +d.financial_vulnerability_index,
    d.share_claiming_social_benefits = +d.share_of_adults_claiming_social_benefits,
    d.share_of_lowell_consumers_in_default = +d.share_of_adults_who_are_lowell_consumers_in_default,
    d.share_using_alternative_financial_products = +d.share_of_adults_using_alternative_financial_products,
    d.share_with_subprime_lending = +d.share_of_lowell_consumers_with_high_cost_loans,
    d.share_without_emergency_savings = +d.share_of_adults_without_emergency_savings,
    d.mapbox_id = +d.mapbox_id
  })

  var mostRecentYear = d3.max(index_data, function(d) { return d.year; });
  var mostRecentQuarter = d3.max(index_data.filter(function(d) { return d.year === mostRecentYear}),
  function(d) { return d.quarter; });

  if(mostRecentQuarter === "Q1") {
    previousPeriodYear === mostRecentYear - 1;
    previousQuarter === "Q4";
  } else {
    previousPeriodYear = mostRecentYear;
    var previousNumber = mostRecentQuarter.slice(1);
    var previousQuarter = "Q" + (Number(previousNumber) - 1);
  }

  dispatch.call("load", this, index_data, search_data, pcs_bboxes, regions_bboxes, mostRecentQuarter, mostRecentYear);
});

dispatch.on("load.searchbox", function(index_data, search_data, mostRecentQuarter) {
  // currently, the searchbox only allows search by postcode for PCs, not for regions/countries
  // this decision was made to minimize the amount of data the user needed to download
  // (there are over 2.6 million unique postcodes in the UK)
  $("#locationSearch").autocomplete({
    autoFocus: true,
    source: function( request, response) {
      var matcher = new RegExp( $.ui.autocomplete.escapeRegex( request.term.replace(/\s/g, "") ), "i" ); // create a regex after stripping out any spaces in the search term
      response(
        $.grep( search_data.filter(function(d) { return d.search_level === "PC"; }), function( value ) {
          value = value.label || value.value || value;
          return matcher.test( value ) || matcher.test( value.replace(/\s/g, "") ); // make matches space-insensitive
        }) );
      },
      search: function() {
        var valueLower = this.value;
        valueLower = valueLower.toLowerCase();
        if(valueLower === "bat" || valueLower === "hov" || valueLower === "corb" || valueLower === "dove" || valueLower === "fyld" || valueLower === "leig" || valueLower === "lewe" || valueLower === "pool" || valueLower === "rugb" || valueLower === "ston" || valueLower === "well" || valueLower === "wiga" || valueLower === "foyl" || valueLower === "angu" || valueLower === "mora" || valueLower === "dely" || valueLower === "gowe" || valueLower === "arfo" || valueLower === "neat") {
          return true;
        }
        else if((this.value.length < 5)) {  // only display options after at least 4 characters are typed because this dataset is really big
          return false;
        } else {
          return true;
        }
      },
      select: function( event, ui ) {

        $("#locationSearch").val(ui.item.label);   // need this so when user clicks on a county name instead of hitting the enter key, the full name is captured (otherwise, only typed letters will get captured)

        selectedGeoID = ui.item.id;
        dispatch.call("geoSelection", this, ui.item.label, selectedGeoID, "searchbox");
      }
      // open: function( event, ui ) {
      //     d3.select("#magnifyGlass").style("visibility", "hidden");
      // },
      // close: function( event, ui ) {
      //     d3.select("#magnifyGlass").style("visibility", "visible");
      // }
    });

    dispatch.on("viewChange.searchbox", function(view) {

      // clear searchbox contents
      $("#locationSearch").val("");

      // update placeholder text
      $("#locationSearch").attr("placeholder", "Search by name" + (view === "PC" ? " or postal code" : ""));

      // update search data
      $("#locationSearch").autocomplete({
        // source: search_data.filter(function(d) { return d.search_level === view; })
        source: function( request, response) {
          var matcher = new RegExp( $.ui.autocomplete.escapeRegex( request.term.replace(/\s/g, "") ), "i" ); // create a regex after stripping out any spaces in the search term
          response(
            $.grep( search_data.filter(function(d) { return d.search_level === view; }), function( value ) {
              value = value.label || value.value || value;
              return matcher.test( value ) || matcher.test( value.replace(/\s/g, "") ); // make matches space-insensitive
            })
          );
        }
      });
    });

    dispatch.on("geoSelection.searchbox", function(selected_geo_name, selected_geo_id, source) {
      $("#locationSearch").val(selected_geo_name);
    });
  }); //"load.searchbox" ends here

  dispatch.on("load.map", function(index_data, search_data, pcs_bboxes, regions_bboxes, mostRecentQuarter, mostRecentYear) {
    d3.select(".findYourScore .mostRecentQuarter").text(mostRecentQuarter + " " + mostRecentYear);

    // Filter data to the most recent quarter of data
    // since we only need most recent data for this part of the tool
    var most_recent_qtr_data = index_data.filter(function(d) { return d.quarter === mostRecentQuarter && d.year === mostRecentYear; });

    initMap(most_recent_qtr_data);

    var dataStick = makeData(most_recent_qtr_data, "National", "");

    var width = d3.select("#panelIndexChart").node().getBoundingClientRect().width,
    margins = {
      top: 10,
      right: 12,
      bottom: 40,
      left: 5
    };

    var stickChartConfig = {
      width: width,
      height: 80,
      margins: {
        top: 10,
        right: 12,
        bottom: 40,
        left: 5
      },
      stickWidth: 1,
      stickRadius: 0
    };

    var range = d3.extent(most_recent_qtr_data, function(d) { return d["financial_vulnerability_index"]; });

    makeStickChart("panelIndexChart", "financial_vulnerability_index", dataStick, range, stickChartConfig);
    populateComponentsPanel(dataStick, "National");

    dispatch.on("viewChange.map", function(view) {

      // when the user switches to a new view, update the map to show that view
      // and reset the charts to only show the UK average
      if(view === "PC") {
        map.setLayoutProperty("PC-fill", "visibility", "visible");
        map.setLayoutProperty("PC-borders", "visibility", "visible");
        map.setLayoutProperty("PC-hover-borders", "visibility", "visible");
        map.setLayoutProperty("Region-fill", "visibility", "none");
        map.setLayoutProperty("Region-borders", "visibility", "none");
        map.setLayoutProperty("Region-hover-borders", "visibility", "none");
      }
      else {
        map.setLayoutProperty("PC-fill", "visibility", "none");
        map.setLayoutProperty("PC-borders", "visibility", "none");
        map.setLayoutProperty("PC-hover-borders", "visibility", "none");
        map.setLayoutProperty("Region-fill", "visibility", "visible");
        map.setLayoutProperty("Region-borders", "visibility", "visible");
        map.setLayoutProperty("Region-hover-borders", "visibility", "visible");
      }

      var dataStick = makeData(most_recent_qtr_data, "National", "");

      updateStickChart("panelIndexChart", "financial_vulnerability_index", dataStick, stickChartConfig);
      populateComponentsPanel(dataStick, "National");
    });

    dispatch.on("geoSelection.map", function(selected_geo_name, selected_geo_id, source) {

      var bounds = (view === "PC") ? pcs_bboxes[selected_geo_id]["bounds"] : regions_bboxes[selected_geo_id]["bounds"];
      zoomIn(bounds);

      var dataStick = makeData(most_recent_qtr_data, view, selected_geo_id);

      updateStickChart("panelIndexChart", "financial_vulnerability_index", dataStick, stickChartConfig);
      populateComponentsPanel(dataStick, view);
    });

    dispatch.on("mapMouseover.map", function(hovered_geo_id) {

      var dataStick = makeData(most_recent_qtr_data, view, hovered_geo_id);

      updateStickChart("panelIndexChart", "financial_vulnerability_index", dataStick, stickChartConfig);
      populateComponentsPanel(dataStick, view);
    });

    dispatch.on("mapMouseout.map", function() {
      // if clicked_geo_id is not null (i.e., a geo was searched for or clicked on in the map),
      // populate the Financial Distress Index and Component Scores sections with that geo's info
      // otherwise, populate those parts with national data only

      if(selectedGeoID) {
        var dataStick = makeData(most_recent_qtr_data, view, selectedGeoID);
        updateStickChart("panelIndexChart", "financial_vulnerability_index", dataStick, stickChartConfig);
        populateComponentsPanel(dataStick, view);
      }
      else {
        var dataStick = makeData(most_recent_qtr_data, "National", "");
        updateStickChart("panelIndexChart", "financial_vulnerability_index", dataStick, stickChartConfig);
        populateComponentsPanel(dataStick, "National");
      }
    });

    dispatch.on("resize.map", function() {
      var width = d3.select("#panelIndexChart").node().getBoundingClientRect().width;

      stickChartConfig['width'] = width;

      resizeStickChart("panelIndexChart", "financial_vulnerability_index", range, stickChartConfig);
    })
  });

  dispatch.on("load.componentsCharts", function(index_data, search_data, pcs_bboxes, regions_bboxes, mostRecentQuarter, mostRecentYear) {
    var fviChartConfig = {
      width: d3.select("#financialVulnerabilityIndexChart").node().getBoundingClientRect().width,
      margins: {
        top: 20,
        right: 17,
        bottom: 40,
        left: 25
      },
      aspectWidth: 3,
      aspectHeight: 3,
      ticksY: 5
    }

    var componentChartConfig = {
      width: d3.select("#consumersDefaultChart").node().getBoundingClientRect().width,
      margins: {
        top: 20,
        right: 12,
        bottom: 40,
        left: 30
      },
      aspectWidth: 3,
      aspectHeight: 2.24,
      ticksY: 4
    }

    // Filter data to the series we need and then Nest
    var filteredData = makeData(index_data, "National", "");

    numberOfQuarters = filteredData.length;

    // For the stick chart, filter data down to just the latest quarter
    var legendData = filteredData.filter(function(d) { return d.quarter === mostRecentQuarter && d.year === mostRecentYear; });
    var stickChartData1720 = filteredData.filter(function(d) {
      return (d.quarter === "Q3" && d.year === "2017") || (d.quarter === "Q1" && d.year === "2020");
    });

    makeLineChart("financialVulnerabilityIndexChart", "financial_vulnerability_index", filteredData, fviChartConfig);
    makeLineChart("consumersDefaultChart", "share_of_lowell_consumers_in_default", filteredData, componentChartConfig);
    makeLineChart("socialBenefitsChart", "share_claiming_social_benefits", filteredData, componentChartConfig);
    makeLineChart("subprimeLendingChart", "share_with_subprime_lending", filteredData, componentChartConfig);
    makeLineChart("creditUseChart", "average_credit_use", filteredData, componentChartConfig);

    var stickChartConfig = {
      width: d3.select("#emergencySavingsBarChart").node().getBoundingClientRect().width,
      height: 100,
      margins: {
        top: 20,
        right: 5,
        bottom: 25,
        left: 5
      },
      stickWidth: 1,
      stickRadius: 0
    };

    prepBarChart("emergencySavingsBarChart", stickChartConfig, stickChartData1720)
    prepBarChart("altFinancialProductsBarChart", stickChartConfig, stickChartData1720)

    makeBarchart("emergencySavingsBarChart", stickChartConfig, stickChartData1720, "share_of_adults_without_emergency_savings")
    makeBarchart("altFinancialProductsBarChart", stickChartConfig, stickChartData1720, "share_of_adults_using_alternative_financial_products")

    populateLegend(legendData);

    dispatch.on("viewChange.componentsCharts", function(view) {
      // when the user switches to a new view, reset the charts to only show the UK average
      filteredData = makeData(index_data, "National", "");

      // subset data to most recent quarter for the stick charts
      var legendData = filteredData.filter(function(d) { return d.quarter === mostRecentQuarter && d.year === mostRecentYear; });

      var stickChartData1720 = filteredData.filter(function(d) {
        return (d.quarter === "Q3" && d.year === "2017") || (d.quarter === "Q1" && d.year === "2020");
      });

      updateLineChart("financialVulnerabilityIndexChart", "financial_vulnerability_index", filteredData, fviChartConfig);
      updateLineChart("consumersDefaultChart", "share_of_lowell_consumers_in_default", filteredData, componentChartConfig);
      updateLineChart("socialBenefitsChart", "share_claiming_social_benefits", filteredData, componentChartConfig);
      updateLineChart("subprimeLendingChart", "share_with_subprime_lending", filteredData, componentChartConfig);
      updateLineChart("creditUseChart", "average_credit_use", filteredData, componentChartConfig);

      makeBarchart("emergencySavingsBarChart", stickChartConfig, stickChartData1720, "share_of_adults_without_emergency_savings")
      makeBarchart("altFinancialProductsBarChart", stickChartConfig, stickChartData1720, "share_of_adults_using_alternative_financial_products")

      populateLegend(legendData);
    });

    dispatch.on("geoSelection.componentsCharts", function(selected_geo_name, selected_geo_id, source) {

      filteredData = makeData(index_data, view, selected_geo_id);

      updateLineChart("financialVulnerabilityIndexChart", "financial_vulnerability_index", filteredData, fviChartConfig);
      updateLineChart("consumersDefaultChart", "share_of_lowell_consumers_in_default", filteredData, componentChartConfig);
      updateLineChart("socialBenefitsChart", "share_claiming_social_benefits", filteredData, componentChartConfig);
      updateLineChart("subprimeLendingChart", "share_with_subprime_lending", filteredData, componentChartConfig);
      updateLineChart("creditUseChart", "average_credit_use", filteredData, componentChartConfig);

      var legendData = filteredData.filter(function(d) { return d.quarter === mostRecentQuarter && d.year === mostRecentYear; });
      //
      // updateStickChart("emergencySavingsChart", "share_without_emergency_savings", stickChartData, stickChartConfig);
      // updateStickChart("altFinancialProductsChart", "share_using_alternative_financial_products", stickChartData, stickChartConfig);

      var stickChartData1720 = filteredData.filter(function(d) {
        return (d.quarter === "Q3" && d.year === "2017") || (d.quarter === "Q1" && d.year === "2020");
      });

      makeBarchart("emergencySavingsBarChart", stickChartConfig, stickChartData1720, "share_of_adults_without_emergency_savings")
      makeBarchart("altFinancialProductsBarChart", stickChartConfig, stickChartData1720, "share_of_adults_using_alternative_financial_products")

      populateLegend(legendData);
    });

    dispatch.on("resize.componentsCharts", function() {
      fviChartConfig['width'] =  d3.select("#financialVulnerabilityIndexChart").node().getBoundingClientRect().width;
      componentChartConfig['width'] = d3.select("#consumersDefaultChart").node().getBoundingClientRect().width;

      resizeLineChart("financialVulnerabilityIndexChart", "financial_vulnerability_index", filteredData, fviChartConfig);
      resizeLineChart("consumersDefaultChart", "share_of_lowell_consumers_in_default", filteredData, componentChartConfig);
      resizeLineChart("socialBenefitsChart", "share_claiming_social_benefits", filteredData, componentChartConfig);
      resizeLineChart("subprimeLendingChart", "share_with_subprime_lending", filteredData, componentChartConfig);
      resizeLineChart("creditUseChart", "average_credit_use", filteredData, componentChartConfig);

      stickChartConfig['width'] = d3.select("#emergencySavingsBarChart").node().getBoundingClientRect().width;

      // resizeStickChart("emergencySavingsChart", "share_without_emergency_savings", rangeEmergencySavings, stickChartConfig);
      // resizeStickChart("altFinancialProductsChart", "share_using_alternative_financial_products", rangeAltFinancialProducts, stickChartConfig);
    });
  });

  function makeData(full_dataset, view, geo_id) {
    var data = [];
    var nationalData = full_dataset.filter(function(d) { return d.geo === "National"; });

    if(view === "PC") {
      var pcData = full_dataset.filter(function(d) { return d.geo_id === geo_id; });
      var region_id = pcData[0].country_or_region_id;
      var regionData = full_dataset.filter(function(d) { return d.geo_id === region_id; });
      return data.concat(pcData, regionData, nationalData);
    }
    else if(view === "Region") {
      var regionData = full_dataset.filter(function(d) { return d.geo_id === geo_id; });
      return data.concat(regionData, nationalData);
    }
    return nationalData;
  }

  function makeLineChart(elementID, metric, data, config) {
    var isMobile = config.width < 400;

    var chartIndent = 0;

    var axisTickExtender = 20;

    var roundTicksFactor = 5;

    var tooltip;

    var width = config.width - config.margins['left'] - config.margins['right'],
    height = Math.ceil((config.width * config.aspectHeight) / config.aspectWidth) - config.margins['top'] - config.margins['bottom'];

    var dataSeries = d3.nest()
    .key(function(d) { return d.geo; })
    .entries(data);

    var min = d3.min(data, function(d) {
      return Math.floor(d[metric] / roundTicksFactor) * roundTicksFactor;
    });

    var max = d3.max(data, function(d) {
      return Math.ceil(d[metric] / roundTicksFactor) * roundTicksFactor;
    })

    var xScale = d3.scaleTime()
    .domain(d3.extent(data.map(function(d) { return d.date; })))
    .range([ 0, width ]);

    var yScale = d3.scaleLinear()
    // .domain(d3.extent(data.map(function(d) { return d[metric]; }))).nice()
    .domain([ min, max ])
    .range([ height, 0 ]);

    var chartElement = d3.select("#" + elementID)
    .append('svg')
    .attr('width', config.width)
    .attr('height', height + config.margins['top'] + config.margins['bottom'])
    .append('g')
    .attr('transform', 'translate(' + config.margins['left'] + ',' + config.margins['top'] + ')');

    // Add chart background for the FVI chart
    if(elementID === "financialVulnerabilityIndexChart") {
      var paddingTop = 20
      chartElement.append("rect")
      .attr("class", "chartBackground")
      .attr("x",  -config.margins['left'])
      .attr("y", -paddingTop)
      .attr("width", config.width)
      .attr("height", height + paddingTop);
    }

    var yAxis = function(g) {
      g.call(d3.axisLeft(yScale)
      .ticks(config.ticksY)
      .tickSize(-width - axisTickExtender)
    )
    .call(function(g) {
      g.selectAll('.domain')
      .remove()
      g.selectAll(".tick text").attr("x", -7).attr("dy", "0.35em")
    });
  }

  var xAxis = function(g) {
    g.attr('transform', "translate(" + chartIndent + "," + height + ")")
    .call(d3.axisBottom(xScale)
    .tickSizeOuter(0)
    .tickFormat(isMobile ? quarterFormatterShort : quarterFormatterLong))
    .call(function(g) {
      g.selectAll('.domain')
      .remove(); }
    )
    .append('path')
    .attr('class', 'domain')
    .attr('d', "M" + -config.margins['left'] + ",0H" + (width + config.margins['right']) ); // draw the x-axis line so it extends into the chart margins
  }

  // Render axes
  chartElement.append('g')
  .attr('class', 'y axis')
  .call(yAxis);

  chartElement.append('g')
  .attr('class', 'x axis')
  .call(xAxis);

  var numTicksX = d3.selectAll('#' + elementID + ' .x.axis .tick')._groups[0].length;

  d3.selectAll('#' + elementID + ' .x.axis .tick')._groups[0].forEach(function(tick, i){
    if(i === 0) {
      var selection = d3.select(tick)
      selection.append('text')
      .text('Q3')
      .attr('class', 'qtr-label')
      .attr('dy',3)
      .attr('y',30)
      .attr('fill','#000000')
    }
    if((elementID === "financialVulnerabilityIndexChart") && (i % 4 === 2)) {
      var selection = d3.select(tick)
      selection.append('text')
      .text('Q1')
      .attr('class', 'qtr-label')
      .attr('dy',3)
      .attr('y',30)
      .attr('fill','#000000')
    }
    // if(i === numTicksX - 1) {
    //     var selection = d3.select(tick)
    //     selection.append('text')
    //         .text('Q2')  // need to update this number when new data are added
    //         .attr('class', 'qtr-label')
    //         .attr('dy',3)
    //         .attr('y',30)
    //         .attr('fill','#000000')
    // }
  })

  // Render lines
  var line = d3.line()
  .defined(function(d) { return !isNaN(d[metric]); })
  .curve(d3.curveLinear)
  .x(function(d) { return xScale(d["date"]); })
  .y(function(d) { return yScale(d[metric]); });

  var lines = chartElement.append("g")
  .attr("class", "lines")
  .selectAll('.line')
  .data(dataSeries, function(d) { return d.key; })
  .enter()
  .append("path")
  .attr('class', function(d) { return "line " + d.key; })
  .attr('d', function(d) { return line(d['values']); })

  makeTooltip(elementID, chartElement, dataSeries, width, height, xScale, yScale, metric, config)

  adjustAxis(elementID, height);
} // make linechart function ends here

function makeTooltip(elementID, chartElement, dataSeries, width, height, xScale, yScale, metric, config) {
  // Tooltip

  var idx;

  tooltip = d3.select("#" + elementID).append("div")
  .attr('id', 'tooltip')
  .style('position', 'absolute')
  .style('display', 'none');

  mouseG = chartElement.append("g")
  .attr("class", "mouse-over-effects");

  mouseG.append("path") // create vertical line to follow mouse
  .attr("class", "mouse-line")
  .style("opacity", "0");

  var mousePerLine = mouseG.selectAll('.mouse-per-line')
  .data(dataSeries)
  .enter()
  .append("g")
  .attr("class", "mouse-per-line");

  mousePerLine.append("circle")
  .attr("r", 4)
  .style("stroke", function (d) {
    if(d.key === "National") {
      return "#adabac";
    } else if(d.key === "Region") {
      return "#151d21";
    } else {
      return "#fdbf11";
    }
  })
  .style("fill", "#FFFFFF")
  .style("stroke-width", "2px")
  .style("opacity", "0");

  mouseG.append('svg:rect') // append a rect to catch mouse movements on canvas
  .attr('width', width + 6)
  .attr('height', height)
  .attr("x", -6)
  .attr('fill', 'none')
  .attr("class", "tooltipRect")
  .attr('pointer-events', 'all')
  .on('mouseout', function () { // on mouse out hide line, circles and text
    var thisLineChart = d3.select("#" + elementID)
    thisLineChart.select(".mouse-line")
    .style("opacity", "0");
    thisLineChart.selectAll(".mouse-per-line circle")
    .style("opacity", "0");
    thisLineChart.selectAll(".mouse-per-line text")
    .style("opacity", "0");
    thisLineChart.selectAll("#tooltip")
    .style('display', 'none')
  })
  .on('mouseover', function () { // on mouse in show line, circles and text
  })
  .on('mousemove', function () { // update tooltip content, line, circles and text when mouse moves
    var mouse = d3.mouse(this)
    var thisLineChart = d3.select("#" + elementID),
    idx,
    xDate,
    bisect;

    thisLineChart.selectAll(".mouse-per-line")
    .attr("transform", function (d, i) {
      var xDate = xScale.invert(mouse[0]) // use 'invert' to get date corresponding to distance from mouse position relative to svg
      var year = xDate.getFullYear(),
      month = xDate.getMonth(),
      quarter = Math.ceil(month / 3 ) + 1;
      var bisect = d3.bisector(function (d) { return d.date; }).left // retrieve row index of date on parsed csv
      idx = bisect(d.values, xDate);

      thisLineChart.select(".mouse-line")
      .attr("d", function () {
        if(idx < numberOfQuarters) {
          var data = "M" + xScale(d.values[idx].date) + "," + (height);
          data += " " + xScale(d.values[idx].date) + "," + 0;
          return data;
        }
      });
      if(idx < numberOfQuarters) {
        return "translate(" + xScale(d.values[idx].date) + "," + yScale(d.values[idx][metric]) + ")";
      }
    });

    var opacityElements;

    if(numberOfQuarters > idx) {
      opacityElements == "1"
    } else {
      opacityElements == "0"
    }

    thisLineChart.selectAll(".mouse-per-line circle")
    .style("opacity", opacityElements);
    thisLineChart.select(".mouse-line")
    .style("opacity", opacityElements);
    thisLineChart.selectAll("#tooltip")
    .style('display', 'block')

    updateTooltipContent(elementID, xScale, yScale, mouse, dataSeries, metric)

  })
}

function updateTooltipContent(elementID, xScale, yScale, mouse, dataSeries, metric) {
  var sortingObj = [],
  quarter,
  idx,
  tooltip;

  dataSeries.map(function(d) {
    var xDate = xScale.invert(mouse[0])
    var bisect = d3.bisector(function (d) { return d.date; }).left
    idx = bisect(d.values, xDate)
    if((numberOfQuarters - 1) >= idx) {
      sortingObj.push({key: d.values[idx].geo, value: d.values[idx][metric], area_name: d.values[idx].geo_name, year: d.values[idx].date.getFullYear(), month: d.values[idx].date.getMonth()})

      quarter = Math.ceil(sortingObj[0].month / 3 ) + 1
    }
  })

  var thisDiv = d3.select("#" + elementID),
  yMargin,
  yPosition;

  if(idx < numberOfQuarters) {
    tooltip = thisDiv.select("#tooltip")
  }

  if(elementID === "financialVulnerabilityIndexChart") {
    if(dataSeries.length === 1) {
      yMargin = 70;
    } else if(dataSeries.length === 2) {
      yMargin = 100;
    } else {
      yMargin = 120;
    }
  } else {
    if(dataSeries.length === 1) {
      yMargin = 12;
    } else if(dataSeries.length === 2) {
      yMargin = 45;
    } else {
      yMargin = 60;
    }
  }

  if(dataSeries.length === 1 && ((numberOfQuarters - 1) >= idx)) {
    yPosition = sortingObj[0].value;
  } else if(dataSeries.length === 2 && ((numberOfQuarters - 1) >= idx)) {
    yPosition = d3.max([sortingObj[0].value, sortingObj[1].value])
  } else {
    if((numberOfQuarters - 1) >= idx) {
      yPosition = d3.max([sortingObj[0].value, sortingObj[1].value, sortingObj[2].value])
    }
  }

  if((numberOfQuarters - 1) >= idx) {
    tooltip.html("<p>" + sortingObj[0].year + " <span class=tooltipQuarter>Q" + quarter + "</span></p><hr>")
    .style('display', 'block')
    .style('left', function() {
      if(idx === (numberOfQuarters - 1)) {
        if(dataSeries.length === 1) {
          return (mouse[0] - 50) + 'px'
        } else {
          return (mouse[0] - 85) + 'px'
        }
      } else if(idx === 0) {
        return (mouse[0] - 35) + 'px'
      } else {
        if(dataSeries.length === 1) {
          return (mouse[0] - 30) + 'px'
        } else {
          return (mouse[0] - 40) + 'px'
        }
      }
    })
    .style('top', function(d) {
      return (yScale(yPosition) - yMargin) + 'px'
    })
    .selectAll()
    .data(sortingObj)
    .enter()
    .append('div')
    .html(function(d) {
      var classValue = "tooltip" + d.key
      return "<p class=geoP>" + d.area_name + ": " + "<strong class=" + classValue + ">" + d.value + "</strong></p>"
    })
  }

}

function updateLineChart(elementID, metric, data, config) {
  var roundTicksFactor = 5;
  var axisTickExtender = 20;

  var width = config.width - config.margins['left'] - config.margins['right'],
  height = Math.ceil((config.width * config.aspectHeight) / config.aspectWidth) - config.margins['top'] - config.margins['bottom'];

  var min = d3.min(data, function(d) {
    return Math.floor(d[metric] / roundTicksFactor) * roundTicksFactor;
  });

  var max = d3.max(data, function(d) {
    return Math.ceil(d[metric] / roundTicksFactor) * roundTicksFactor;
  });

  var xScale = d3.scaleTime()
  .domain(d3.extent(data.map(function(d) { return d.date; })))
  .range([ 0, width ]);

  var yScale = d3.scaleLinear()
  // .domain(d3.extent(data.map(function(d) { return d[metric]; }))).nice()
  .domain([ min, max ])
  .range([ height, 0 ]);

  d3.selectAll("#" + elementID + " .y.axis")
  .transition()
  // .duration(3000)
  .call(d3.axisLeft(yScale)
  .ticks(config.ticksY)
  .tickSize(-width - axisTickExtender)
)
.call(function(g) {
  g.selectAll('.domain')
  .remove(); }
)
.on("end", function() { adjustAxis(elementID, height); });

var dataSeries = d3.nest()
.key(function(d) { return d.geo; })
.entries(data);

var line = d3.line()
.defined(function(d) { return !isNaN(d[metric]); })
.curve(d3.curveLinear)
.x(function(d) { return xScale(d["date"]); })
.y(function(d) { return yScale(d[metric]); });

var lines = d3.select("#" + elementID + " svg g g.lines")
.selectAll(".line")
.data(dataSeries, function(d) { return d.key; });

lines.exit().remove();

lines.enter()
.append("path")
.attr("class", function(d) { return "line " + d.key; })
.merge(lines)
.transition()
.attr("d", function(d) { return line(d.values); });

var chartElement = d3.select("#" + elementID)

var mouseG = chartElement.selectAll("g.mouse-over-effects")

var theDots = mouseG.selectAll("g.mouse-per-line")
.data(dataSeries)

theDots.exit().remove();

theDots.enter()
.append("g")
.attr("class", "mouse-per-line")
.merge(theDots)
.style("stroke", function (d) {
  if(d.key === "National") {
    return "#adabac";
  } else if(d.key === "Region") {
    return "#151d21";
  } else {
    return "#fdbf11";
  }
})
.append("circle")
.attr("r", 4)
.style("fill", "#FFFFFF")
.style("stroke-width", "2px")
.style("opacity", "0");

var mouseG = chartElement.selectAll("g.mouse-over-effects")
.on('mouseout', function() {
  chartElement.select("#tooltip").style("display", "none")
})
.on('mousemove', function() {
  var mouse = d3.mouse(this)
  var thisLineChart = d3.select("#" + elementID)

  thisLineChart.selectAll(".mouse-per-line")
  .attr("transform", function (d, i) {
    var xDate = xScale.invert(mouse[0]) // use 'invert' to get date corresponding to distance from mouse position relative to svg
    var year = xDate.getFullYear(),
    month = xDate.getMonth(),
    quarter = Math.ceil(month / 3 ) + 1;
    var bisect = d3.bisector(function (d) { return d.date; }).left // retrieve row index of date on parsed csv
    var idx = bisect(d.values, xDate);

    thisLineChart.select(".mouse-line")
    .attr("d", function () {
      if((numberOfQuarters - 1) >= idx) {
        var data = "M" + xScale(d.values[idx].date) + "," + (height);
        data += " " + xScale(d.values[idx].date) + "," + 0;
        return data;
      }

    });

    if((numberOfQuarters - 1) >= idx) {
      return "translate(" + xScale(d.values[idx].date) + "," + yScale(d.values[idx][metric]) + ")";
    }
  });

  updateTooltipContent(elementID, xScale, yScale, mouse, dataSeries, metric)
})
}

function resizeLineChart(elementID, metric, data, config) {
  var width = config.width - config.margins['left'] - config.margins['right'],
  height = Math.ceil((config.width * config.aspectHeight) / config.aspectWidth) - config.margins['top'] - config.margins['bottom'];

  var isMobile = config.width < 400;

  var roundTicksFactor = 5;

  var min = d3.min(data, function(d) {
    return Math.floor(d[metric] / roundTicksFactor) * roundTicksFactor;
  });

  var max = d3.max(data, function(d) {
    return Math.ceil(d[metric] / roundTicksFactor) * roundTicksFactor;
  })

  var xScale = d3.scaleTime()
  .domain(d3.extent(data.map(function(d) { return d.date; })))
  .range([ 0, width ]);

  var yScale = d3.scaleLinear()
  // .domain(d3.extent(data.map(function(d) { return d[metric]; }))).nice()
  .domain([ min, max ])
  .range([ height, 0 ]);

  d3.select("#" + elementID + " svg")
  .attr('width', config.width)
  .attr('height', height + config.margins['top'] + config.margins['bottom']);

  if(elementID === "financialVulnerabilityIndexChart") {
    d3.select("#financialVulnerabilityIndexChart rect")
    .attr("x",  -config.margins['left'])
    .attr("y", 0)
    .attr("width", config.width)
    .attr("height", height);
  }

  d3.selectAll("#" + elementID + " .y.axis")
  .transition()
  // .duration(3000)
  .call(d3.axisLeft(yScale)
  .ticks(config.ticksY)
  .tickSize(-width)
)
.call(function(g) {
  g.selectAll('.domain')
  .remove(); }
);

d3.selectAll("#" + elementID + " .x.axis")
.transition()
.attr('transform', "translate(0," + height + ")")
.call(d3.axisBottom(xScale)
.tickSizeOuter(0)
.tickFormat(isMobile ? quarterFormatterShort : quarterFormatterLong)
)
.call(function(g) {
  g.selectAll('.domain')
  .remove(); }
);

d3.selectAll("#" + elementID + " .x.axis")
.append('path')
.attr('class', 'domain')
.attr('d', "M" + -config.margins['left'] + ",0H" + (width + config.margins['right']) );

var line = d3.line()
.defined(function(d) { return !isNaN(d[metric]); })
.curve(d3.curveLinear)
.x(function(d) { return xScale(d["date"]); })
.y(function(d) { return yScale(d[metric]); });

d3.selectAll("#" + elementID + " .line")
.transition()
.attr("d", function(d) { return line(d["values"]); });

adjustAxis(elementID, height);
}

function makeStickChart(elementID, metric, data, range, config) {
  var width = config.width - config.margins['left'] - config.margins['right'],
  height = config.height - config.margins['top'] - config.margins['bottom'];

  // make the top "table" of numbers and place names
  var table = d3.select("#" + elementID)
  .append("div")
  .attr("class", "container");

  var columns = table.selectAll(".column")
  .data(data)
  .enter()
  .append("div")
  .attr("class", function(d) { return "column " + d.geo; });

  columns.append("span")
  .attr("class", "number")
  .text(function(d) { return metric === "financial_vulnerability_index" ? COMMAFORMAT(d[metric]) : COMMAFORMAT(d[metric]) + "%"; });

  columns.append("div")
  .attr("class", "geoName")
  .text(function(d) { return d.geo_name; });

  // make stick chart
  var xScale = d3.scaleLinear()
  .domain([0, 100])
  .range([0, width]);

  var chartElement = d3.select("#" + elementID)
  .append("svg")
  .attr('width', config.width)
  .attr('height', config.height)
  .append('g')
  .attr('transform', 'translate(' + config.margins['left'] + ',' + config.margins['top'] + ')');

  var xAxis = function(g) {
    g.attr('transform', "translate(0," + height + ")")
    .call(d3.axisBottom(xScale)
    .ticks(5)
    .tickSizeOuter(0));
  }

  var sticks = chartElement.selectAll(".stick")
  .data(data, function(d) { return d.geo; })
  .enter()
  .append("rect")
  .attr("class", function(d) { return "stick " + d.geo ; })
  .attr("x", function(d) { return xScale(d[metric]) - 2; }) // "center" the rectangle
  .attr("width", config.stickWidth)
  .attr("y", 0)
  .attr("height", height)
  .attr("rx", config.stickRadius);

  // Shade in range of scores on the x-axis
  var scoreRange = chartElement.append('g')
  .attr('class', 'scoreRange')
  .attr('transform', 'translate(0,' + height + ')');

  scoreRange.append('rect')
  .attr('x', xScale(range[0]))
  .attr('y', 0)
  .attr('width', xScale(range[1] - range[0]))
  .attr('height', 26)
  .attr('rx', 2);

  scoreRange.append('text')
  .attr('x', Math.max(53, ( xScale(range[0]) + xScale(range[1]) ) / 2 ))
  .attr('y', 40)
  .text('Range of Scores');

  chartElement.append('g')
  .attr('class', 'x axis')
  .call(xAxis);
}

function updateStickChart(elementID, metric, data, config) {
  var width = config.width - config.margins['left'] - config.margins['right'],
  height = config.height - config.margins['top'] - config.margins['bottom'];

  var columns = d3.select("#" + elementID + " .container")
  .selectAll(".column")
  .data(data);

  columns.exit().remove();

  var columnsEnter = columns.enter()
  .append("div")

  columnsEnter.append("span")
  .attr("class", "number");

  columnsEnter.append("div")
  .attr("class", "geoName");

  columnsEnter = columnsEnter.merge(columns)
  .attr("class", function(d) { return "column " + d.geo; });

  columnsEnter.select(".number")
  .text(function(d) { return metric === "financial_vulnerability_index" ? COMMAFORMAT(d[metric]) : COMMAFORMAT(d[metric]) + "%"; });

  columnsEnter.select(".geoName")
  .text(function(d) { return d.geo_name; });

  var xScale = d3.scaleLinear()
  .domain([0, 100])
  .range([0, width]);

  var sticks = d3.select("#" + elementID + " svg g")
  .selectAll(".stick")
  .data(data, function(d) { return d.geo; });

  sticks.exit().remove();

  sticks.enter()
  .append("rect")
  .attr("class", function(d) { return "stick " + d.geo; })
  .merge(sticks)
  .transition()
  .attr("class", function(d) { return "stick " + d.geo ; })
  .attr("x", function(d) { return xScale(d[metric]) - 2; })
  .attr("width", config.stickWidth)
  .attr("y", 0)
  .attr("height", height)
  .attr("rx", config.stickRadius);
}

function resizeStickChart(elementID, metric, range, config) {
  var width = config.width - config.margins['left'] - config.margins['right'],
  height = config.height - config.margins['top'] - config.margins['bottom'];

  var xScale = d3.scaleLinear()
  .domain([0, 100])
  .range([0, width]);

  d3.select("#" + elementID + " svg")
  .attr('width', config.width)
  .attr('height', config.height);

  d3.selectAll("#" + elementID + " .x.axis")
  .transition()
  .attr('transform', "translate(0," + height + ")")
  .call(d3.axisBottom(xScale)
  .ticks(5)
  .tickSizeOuter(0));

  d3.select('#' + elementID + ' .scoreRange rect')
  .attr('x', xScale(range[0]))
  .attr('width', xScale(range[1] - range[0]));

  d3.select('#' + elementID +  ' .scoreRange text')
  .attr('x', Math.max(53, ( xScale(range[0]) + xScale(range[1]) ) / 2 ));

  d3.selectAll("#" + elementID + " .stick")
  .transition()
  .attr("x", function(d) { return xScale(d[metric]) - 2; });
}

function prepBarChart(elementID, config, data) {

  var width = config.width - config.margins['left'] - config.margins['right'],
  height = config.height - config.margins['top'] - config.margins['bottom'];

  var chartElement = d3.select("#" + elementID)
  .append("svg")
  .attr('width', width + config.margins['left'] + config.margins['right'])
  .attr('height', height + config.margins['top'] + config.margins['bottom'])
  .append('g')
  .attr('transform', 'translate(0,' + config.margins['top'] + ')');

  var nestedData = d3.nest()
  .key(function(d) {
    return d.year
  })
  .entries(data)

  var gElements = chartElement.selectAll("g.bars")
  .data(nestedData)
  .enter()
  .append("g")
  .attr("class", "bars")
  .attr("id", function(d) {
    return "data-" + d.key
  })
  .attr("width", function(d) {
    return (width / 2) - config.margins['left']
  })
  .attr('transform', function(d, i) {
    if(i === 0) {
      return 'translate(' + i + ', 0)'
    } else {
      var xPosition = (width / 2) + config.margins['left'] + config.margins['right']
      return 'translate(' + xPosition + ', 0)'
    }
  });

  var xScale = d3.scaleBand()
  .domain(data.map(function(d) {
    return d.geo;
  }))
  .range([0, (width + config.margins['left'] + config.margins['right'])])

  var xAxis = function(g) {
    g.attr('transform', "translate(0," + height + ")")
    .call(d3.axisBottom(xScale)
    .ticks(0)
    .tickSize(0))
    .call(function(g) {
      g.selectAll('text')
      .remove(); }
    )
  }

  // Render axes
  chartElement.append('g')
  .attr('class', 'x axis')
  .call(xAxis);

  function textAxis(thisId, text) {
    var legendTime = chartElement.select(thisId)
    .append("text")
    .attr("class", "periods")
    .attr("x", width / 4)
    .attr("y", height)
    .attr("dy", "1.2em")
    .attr("text-anchor", "middle")
    .text(text)
  }

  textAxis("#data-2017", "April 2017")
  textAxis("#data-2020", "February 2020")
}

function makeBarchart(elementID, config, data, metric) {

  function hideNUTS2note(data) {
    var dataPoints = (data.length / 2)

    if(dataPoints < 3) {
      d3.selectAll(".noteUK").style("display", "block");
      d3.selectAll(".notePC").style("display", "none");
    } else {
      d3.selectAll(".noteUK").style("display", "none");
      d3.selectAll(".notePC").style("display", "block");
    }
  }

  hideNUTS2note(data)

  var width = config.width - config.margins['left'] - config.margins['right'],
  height = config.height - config.margins['top'] - config.margins['bottom'];

  var maxData;

  var maxValueEmergencySavings = d3.max(data, function(d) { return +d.share_of_adults_without_emergency_savings; });
  var maxValueAlternative = d3.max(data, function(d) {
    return +d.share_of_adults_using_alternative_financial_products;
  })

  function roundTo510(numberToRound) {
    return Math.ceil(numberToRound / 5) * 5;
  }

  if(maxValueAlternative > maxValueEmergencySavings) {
    maxData = roundTo510(maxValueAlternative)
  } else {
    maxData = roundTo510(maxValueEmergencySavings)
  }

  var yScale = d3.scaleLinear()
  .domain([0, maxData])
  .range([height, 0]);

  var xScale = d3.scaleBand()
  .domain(data.map(function(d) {
    return d.geo;
  }))
  .range([0, width / 2])
  .padding(0.1);

  var nestedData = d3.nest()
  .key(function(d) {
    return d.year
  })
  .entries(data)

  var theBars = d3.select("#" + elementID).selectAll(".bars")
  .data(nestedData)
  .selectAll("rect")
  .data(function(d) {
    return d.values;
  })
  .attr("class", function(d, i) {
    var thisClass = "class-" + d.geo;
    return thisClass;
  })

  theBars.exit().remove();

  theBars.enter()
  .append("rect")
  .attr("class", function(d, i) {
    return "bar-" + d.geo;
  })
  .merge(theBars)
  .attr("class", function(d, i) {
    var thisClass = "class-" + d.geo;
    return thisClass
  })
  .attr("fill", function(d) {
    if(d.geo === "National") {
      return "#9d9d9d";
    } else if(d.geo === "Region") {
      return "#151d21";
    } else {
      return "#fdbf11";
    }
  })
  .attr("x", function(d) { return xScale(d.geo); })
  .attr("y", function(d) { return yScale(d[metric]); })
  .attr("width", (xScale.bandwidth()))
  .attr("height", function(d) {
    return height - yScale(+d[metric]);
  })

  var theLabels = d3.select("#" + elementID).selectAll(".bars")
  .data(nestedData)
  .selectAll("text.numbers-bars")
  .data(function(d) {
    return d.values
  })

  theLabels.exit().remove()

  theLabels.enter()
  .append("text")
  .attr("class", "numbers-bars")
  .attr("dy", "-.5em")
  .attr("text-anchor", "middle")
  .merge(theLabels)
  .attr("x", function(d, i) {
    return xScale(d.geo) + (xScale.bandwidth() / 2 )
  })
  .attr("y", function(d) {
    return yScale(+d[metric])
  })
  .text(function(d) {
    return COMMAFORMAT(d[metric]) + "%";
  })
}

function populateLegend(data) {
  // populate the legend that appears below the Financial Vulnerability
  // Index chart in the Go Deeper section
  var legend = d3.select(".components .legend");

  if(data.length === 1) {
    legend.select(".legendEntry.pc").classed("hidden", true);
    legend.select(".legendEntry.region").classed("hidden", true);
  }
  else if(data.length === 2) {
    legend.select(".legendEntry.pc").classed("hidden", true);
    legend.select(".legendEntry.region").classed("hidden", false);

    legend.select(".legendLabel.region").text(data.filter(function(d) { return d.geo === "Region"; })[0]["geo_name"]);
  }
  else {
    legend.select(".legendEntry.pc").classed("hidden", false);
    legend.select(".legendEntry.region").classed("hidden", false);

    legend.select(".legendLabel.pc").text(data.filter(function(d) { return d.geo === "PC"; })[0]["geo_name"]);
    legend.select(".legendLabel.region").text(data.filter(function(d) { return d.geo === "Region"; })[0]["geo_name"]);
  }
}

function populateComponentsPanel(data, view) {
  // show or hide bars based on which geo is selected

  if(data[0].year === "2020") {
    data = data.filter(function(d) {
      return d.year === "2020"
    })
  } else {
    data = data.filter(function(d) {
      return d.year === "2021"
    })
  }

  if(data.length === 1) {
    d3.selectAll(".componentScores .chart .PC").style("display", "none");
    d3.selectAll(".componentScores .chart .Region").style("display", "none");
  }
  else if(data.length === 2) {
    d3.selectAll(".componentScores .chart .PC").style("display", "none");
    d3.selectAll(".componentScores .chart .Region").style("display", "block");
  }
  else {
    d3.selectAll(".componentScores .chart .PC").style("display", "block");
    d3.selectAll(".componentScores .chart .Region").style("display", "block");
  }

  var metricElementMap = {
    inDefault: "share_of_lowell_consumers_in_default",
    socialBenefits: "share_claiming_social_benefits",
    subprimeLending: "share_with_subprime_lending",
    creditUse: "average_credit_use",
    emergencySavings: "share_without_emergency_savings",
    altFinancialProducts: "share_using_alternative_financial_products"
  }

  Object.keys(metricElementMap).forEach(function(element) {
    // the numbers in the table are for the most specific geography selected
    populateTableNumbers(element, view);

    // adjust length of bars
    d3.select("." + element + " .National")
    .style("width", data.filter(function(d) { return d.geo === "National"; })[0][metricElementMap[element]] + "%");

    if(data.length === 3) {
      d3.select("." + element + " .PC")
      .style("width", data.filter(function(d) { return d.geo === "PC"; })[0][metricElementMap[element]] + "%");
    }

    if(data.length >= 2) {
      d3.select("." + element + " .Region")
      .style("width", data.filter(function(d) { return d.geo === "Region"; })[0][metricElementMap[element]] + "%");
    }
  });

  function populateTableNumbers(element, view) {
    d3.select("." + element + " .number > span")
    .attr("class", "number " + view + "Number")
    .text(COMMAFORMAT(data.filter(function(d) { return d.geo === view; })[0][metricElementMap[element]]) + "%");
  }

  d3.selectAll(".componentScores .chart div").on("mouseover", function() {
    var hoveredView = d3.select(this).attr("class");

    if(hoveredView === "National" || hoveredView === "Region") {
      d3.selectAll(".noteUK").style("display", "block");
      d3.selectAll(".notePC").style("display", "none");
    } else {
      d3.selectAll(".noteUK").style("display", "none");
      d3.selectAll(".notePC").style("display", "block");
    }

    // populate table with numbers corresponding to the geo level of the bar that's hovered over
    // (i.e., if hovering over the region bar, show region values in the table)
    Object.keys(metricElementMap).forEach(function(element) {
      populateTableNumbers(element, hoveredView);
    });

  });

  d3.selectAll(".componentScores .chart div").on("mouseout", function() {

    if(view === "National" || view === "Region") {
      d3.selectAll(".noteUK").style("display", "block");
      d3.selectAll(".notePC").style("display", "none");
    } else {
      d3.selectAll(".noteUK").style("display", "none");
      d3.selectAll(".notePC").style("display", "block");
    }

    Object.keys(metricElementMap).forEach(function(element) {
      populateTableNumbers(element, view);
    });
  });
}

function initMap(index_data){

  mapboxgl.accessToken = 'pk.eyJ1IjoidXJiYW5pbnN0aXR1dGUiLCJhIjoiTEJUbmNDcyJ9.mbuZTy4hI_PWXw3C3UFbDQ';

  map = new mapboxgl.Map({
    attributionControl: false,
    container: 'map',
    //style: 'mapbox://styles/urbaninstitute/ckjkfrl3g1jqk19mee5uwvubf',
    style: 'mapbox://styles/urbaninstitute/ckux4bqdd7e4417pfxbb01m3h/draft',
    center: [-2.5, 54.356],
    zoom: 4.5,
    maxZoom: 11,
    minZoom: 3.5
  });

  var hoverGeoID = null, // track which geo is mousedover
  clickedGeoID = null,
  hoverGeoID_orig,
  clickedGeoID_orig;

  map.on('load', function() {
    // make the tract outlines in the *-hover-borders layer transparent initially
    // as geos are hovered over, that geo's border's opacity will be set to 1
    map.setPaintProperty(
      'PC-hover-borders',
      'line-opacity',
      [
        'case',
        ['boolean', ['feature-state', 'highlight'], false],
        1,
        0
      ]
    );

    map.setPaintProperty(
      'Region-hover-borders',
      'line-opacity',
      [
        'case',
        ['boolean', ['feature-state', 'highlight'], false],
        1,
        0
      ]
    );

    // disable map rotation using right click + drag
    map.dragRotate.disable();

    // disable map rotation using touch rotation gesture
    map.touchZoomRotate.disableRotation();

    // on tablet and phone screens, disable map zoom when using scroll
    if(d3.select(".container").node().getBoundingClientRect().width < 1000) {
      map.scrollZoom.disable();
    }

    // hover behavior adapted from: https://docs.mapbox.com/help/tutorials/create-interactive-hover-effects-with-mapbox-gl-js/
    // also a good resource: https://blog.mapbox.com/going-live-with-electoral-maps-a-guide-to-feature-state-b520e91a22d
    map.on('mousemove', 'PC-fill', function(e) { // detect mousemove on the fill layer instead of stroke layer so correct geo is highlighted

      map.getCanvas().style.cursor = 'pointer';

      // Check whether features exist
      if (e.features.length > 0) {

        // If geoID for the hovered feature is not null,
        // use removeFeatureState to reset to the default behavior
        if (hoverGeoID) {
          map.removeFeatureState({
            source: 'composite',  // can find what the source and sourceLayer are from console logging e.features[0]["layer"]
            sourceLayer: 'pcsid',
            id: hoverGeoID
          });
        }

        hoverGeoID = e.features[0]["id"]; // this is the Mapbox numeric id
        hoverGeoID_orig = e.features[0]["properties"]["geo_id"]; // this is the ID that links to the rest of the data

        // When the mouse moves over the tract-hover-strokes layer, update the
        // feature state for the feature under the mouse
        map.setFeatureState({
          source: 'composite',
          sourceLayer: 'pcsid',
          id: hoverGeoID
        },
        {
          highlight: true
        });

        dispatch.call("mapMouseover", this, hoverGeoID_orig);

        // if a geo has been clicked on, make sure it is still highlighted
        if(clickedGeoID) {
          map.setFeatureState({
            source: 'composite',
            sourceLayer: 'pcsid',
            id: clickedGeoID
          }, {
            highlight: true
          });
        }
      }
    });

    map.on("mouseleave", "PC-fill", function() {

      if (hoverGeoID) {
        map.setFeatureState({
          source: 'composite',
          sourceLayer: 'pcsid',
          id: hoverGeoID
        }, {
          highlight: false
        });
      }

      hoverGeoID = null;

      // if a geo has been clicked on, keep it highlighted
      if(clickedGeoID) {
        map.setFeatureState({
          source: 'composite',
          sourceLayer: 'pcsid',
          id: clickedGeoID
        }, {
          highlight: true
        });
      }

      dispatch.call("mapMouseout", this);

      // Reset the cursor style
      map.getCanvas().style.cursor = '';
    });

    map.on("click", "PC-fill", function(e) {

      if(e.features.length > 0) {
        // stop highlighting any previously clicked on tracts
        if (clickedGeoID) {
          map.removeFeatureState({
            source: 'composite',
            sourceLayer: 'pcsid',
            id: clickedGeoID
          });
        }

        clickedGeoID = e.features[0].id;
        clickedGeoID_orig = e.features[0].properties["geo_id"];
        clickedGeoName = e.features[0].properties["PCON17NM"];
        selectedGeoID = clickedGeoID_orig;

        map.setFeatureState({
          source: 'composite',
          sourceLayer: 'pcsid',
          id: clickedGeoID
        },
        {
          highlight: true
        });

        dispatch.call("geoSelection", this, clickedGeoName, clickedGeoID_orig, "map");
      }
    });

    // repeat above setup for the region layers
    map.on('mousemove', 'Region-fill', function(e) {

      map.getCanvas().style.cursor = 'pointer';

      if (e.features.length > 0) {

        if (hoverGeoID) {
          map.removeFeatureState({
            source: 'composite',
            sourceLayer: 'regionsid',
            id: hoverGeoID
          });
        }

        hoverGeoID = e.features[0]["id"];
        hoverGeoID_orig = e.features[0]["properties"]["geo_id"];

        map.setFeatureState({
          source: 'composite',
          sourceLayer: 'regionsid',
          id: hoverGeoID
        },
        {
          highlight: true
        });

        dispatch.call("mapMouseover", this, hoverGeoID_orig);

        if(clickedGeoID) {
          map.setFeatureState({
            source: 'composite',
            sourceLayer: 'regionsid',
            id: clickedGeoID
          }, {
            highlight: true
          });
        }
      }
    });

    map.on("mouseleave", "Region-fill", function() {

      if (hoverGeoID) {
        map.setFeatureState({
          source: 'composite',
          sourceLayer: 'regionsid',
          id: hoverGeoID
        }, {
          highlight: false
        });
      }

      hoverGeoID = null;

      if(clickedGeoID) {
        map.setFeatureState({
          source: 'composite',
          sourceLayer: 'regionsid',
          id: clickedGeoID
        }, {
          highlight: true
        });
      }

      dispatch.call("mapMouseout", this);

      map.getCanvas().style.cursor = '';
    });

    map.on("click", "Region-fill", function(e) {

      if(e.features.length > 0) {
        if (clickedGeoID) {
          map.removeFeatureState({
            source: 'composite',
            sourceLayer: 'regionsid',
            id: clickedGeoID
          });
        }

        clickedGeoID = e.features[0].id;
        clickedGeoID_orig = e.features[0].properties["geo_id"];
        clickedGeoName = e.features[0].properties["nuts118nm"];
        selectedGeoID = clickedGeoID_orig;

        map.setFeatureState({
          source: 'composite',
          sourceLayer: 'regionsid',
          id: clickedGeoID
        },
        {
          highlight: true
        });

        dispatch.call("geoSelection", this, clickedGeoName, clickedGeoID_orig, "map");
      }
    });

    function waitForLoad(){
      if(map.loaded()) {
        // unhide charts and maps and hide the loading gif after data has loaded
        // and tool has populated
        // this seems to remove the loading gif a little before the map has rendered though
        d3.selectAll("section.loading").classed("loading", false);
        d3.select("#loadingGif").classed("hidden", true);
      }
      else setTimeout(waitForLoad, 200);
    }

    waitForLoad();
  });

  map.addControl(new mapboxgl.NavigationControl({"showCompass": false}), "bottom-right");

  dispatch.on("viewChange.mapboxMap", function(view) {
    // remove any highlighted PCs or regions when the view is changed
    // and reset clickedGeoID to be null
    map.setFeatureState({
      source: 'composite',
      sourceLayer: 'pcsid',
      id: clickedGeoID
    }, {
      highlight: false
    });

    map.setFeatureState({
      source: 'composite',
      sourceLayer: 'regionsid',
      id: clickedGeoID
    }, {
      highlight: false
    });

    clickedGeoID = null;
  });

  dispatch.on("geoSelection.mapboxMap", function(selected_geo_name, selected_geo_id, source) {
    // first clear any previous highlighting (i.e., if the user previously clicked on the map)
    map.setFeatureState({
      source: 'composite',
      sourceLayer: 'pcsid',
      id: clickedGeoID
    }, {
      highlight: false
    });

    map.setFeatureState({
      source: 'composite',
      sourceLayer: 'regionsid',
      id: clickedGeoID
    }, {
      highlight: false
    });

    // get the mapbox ID for the selected geo
    clickedGeoID = index_data.filter(function(d) { return d.geo_id === selected_geo_id})[0]["mapbox_id"];

    if(view === "PC") {
      map.setFeatureState({
        source: 'composite',
        sourceLayer: 'pcsid',
        id: clickedGeoID
      }, {
        highlight: true
      });
    }
    else {
      map.setFeatureState({
        source: 'composite',
        sourceLayer: 'regionsid',
        id: clickedGeoID
      }, {
        highlight: true
      });
    }
  });
}

function zoomIn(bounds) {
  map.fitBounds(
    bounds,
    {
      "padding": 20,
      "duration": 900,
      "essential": true, // If true, then the animation is considered essential and will not be affected by prefers-reduced-motion .
    }
  );
}

var quarterFormatterLong = function(date, i) {
  // display the 4-digit year for Q1, nothing for all other quarters
  // except the first and last quarters of data
  // code from here: https://stackoverflow.com/questions/26921414/d3js-x-axis-data-by-quarter-sub-grouped-by-year

  var year = date.getFullYear(),
  month = date.getMonth(),
  quarter = Math.ceil(month / 3 ) + 1;

  if(quarter === 1 | i === 0) {
    return year;
  }
}

var quarterFormatterShort = function(date, i) {
  // display the 2-digit year for Q1, nothing for all other quarters
  // except the first and last quarters of data
  // code from here: https://stackoverflow.com/questions/26921414/d3js-x-axis-data-by-quarter-sub-grouped-by-year

  var year = date.getFullYear(),
  month = date.getMonth(),
  quarter = Math.ceil(month / 3 ) + 1;

  if(quarter === 1 | i === 0) {
    return "'" + year % 2000;
  }
}

d3.selection.prototype.moveToFront = function() {
  return this.each(function(){
    this.parentNode.appendChild(this);
  });
};


function adjustAxis(elementID, height){

  //JBC here with my gross code!
  var yAxisSelection = d3.selectAll('#' + elementID + ' .y.axis')
  yAxisSelection.selectAll('.tick line').attr('x1', -25 )
  yAxisSelection.selectAll('.tick text').attr('y', -10)

  // if the lowest tick mark is too close to the x-axis to fit the
  // tick label without overlapping, delete it
  // THIS DOES NOT WORK
  // d3.selectAll('#' + elementID + ' .y.axis .tick')._groups[0].forEach(function(tick, i){
  //     console.log(d3.select(tick).attr('transform'));
  //     var tickTranslate = d3.select(tick).attr('transform');
  //     var tickTranslateY = +tickTranslate.split(',')[1].split(')')[0]; // couldn't find an easy way to get the translation coordinates
  //     if(height - tickTranslateY <= 13) {
  //         d3.select(tick).style('display', 'none')
  //     }
  // });
}

// EVENT LISTENERS
d3.selectAll("input[name='geoType']")
.on("click", function() { view = getSelectedView();
  selectedGeoID = null;
  dispatch.call("viewChange", this, view);
});

  // d3.select("#locationSearch").on("click", function() { $("#locationSearch").val(""); });

  function getSelectedView() {
    return d3.select("input[name='geoType']:checked").node().value;
  }

  window.addEventListener("resize", redraw);

  function redraw() {
    dispatch.call("resize", this);
  }
