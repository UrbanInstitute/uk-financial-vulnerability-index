// variables to catch "initial" state
var view = "PC";
var selectedGeoID = null;

var data,
    searchData;

var dispatch = d3.dispatch("load", "viewChange", "geoSelection", "mapMouseover", "mapMouseout", "resize");

var COMMAFORMAT = d3.format(",.1f");

// POLYFILL FOR IE which doesn't support .forEach() on node lists
if (typeof Array.prototype.forEach != 'function') {
    Array.prototype.forEach = function (callback) {
        for (var i = 0; i < this.length; i++) {
            callback.apply(this, [this[i], i, this]);
        }
    };
}

if (window.NodeList && !NodeList.prototype.forEach) {
    NodeList.prototype.forEach = Array.prototype.forEach;
}

d3.queue()
    .defer(d3.csv, "data/index_data.csv")
    .defer(d3.json, "data/pcs_bboxes.json")
    .defer(d3.json, "data/regions_bboxes.json")
    .defer(d3.csv, "data/search_data_v2.csv")
.await(function(error, index_data, pcs_bboxes, regions_bboxes, search_data) {

    if(error) throw error;

    index_data.forEach(function(d) {
        d.average_credit_use = +d.average_credit_use,
        d.date = d3.timeParse("%Y-%m-%d")(d.date),
        d.financial_vulnerability_index = +d.financial_vulnerability_index,
        d.share_claiming_social_benefits = +d.share_claiming_social_benefits,
        d.share_of_lowell_consumers_in_default = +d.share_of_lowell_consumers_in_default,
        d.share_using_alternative_financial_products = +d.share_using_alternative_financial_products,
        d.share_with_subprime_lending = +d.share_with_subprime_lending,
        d.share_without_emergency_savings = +d.share_without_emergency_savings,
        d.mapbox_id = +d.mapbox_id
    })

    var mostRecentYear = d3.max(index_data, function(d) { return d.year; });
    var mostRecentQuarter = d3.max(index_data.filter(function(d) { return d.year === mostRecentYear}),
        function(d) { return d.quarter; });

    dispatch.call("load", this, index_data, search_data, pcs_bboxes, regions_bboxes, mostRecentQuarter, mostRecentYear);
});

dispatch.on("load.searchbox", function(index_data, search_data, mostRecentQuarter) {
    // currently, the searchbox only allows search by postcode for PCs, not for regions/countries
    // this decision was made to minimize the amount of data the user needed to download
    // (there are over 2.6 million unique postcodes in the UK)
    $("#locationSearch").autocomplete({
        autoFocus: true,
        source: function( request, response) {
            var matcher = new RegExp( $.ui.autocomplete.escapeRegex( request.term.replace(/\s/g, "") ), "i" ); // create a regex after stripping out any spaces in the search term
            response( $.grep( search_data.filter(function(d) { return d.search_level === "PC"; }), function( value ) {
                value = value.label || value.value || value;
                return matcher.test( value ) || matcher.test( value.replace(/\s/g, "") ); // make matches space-insensitive
            }) );
        },
        search: function() {
            if(this.value.length < 4) {  // only display options after at least 4 characters are typed because this dataset is really big
                return false;
            }
        },
        select: function( event, ui ) {
            // console.log(ui.item);
            $("#locationSearch").val(ui.item.label);   // need this so when user clicks on a county name instead of hitting the enter key, the full name is captured (otherwise, only typed letters will get captured)

            selectedGeoID = ui.item.id;
            dispatch.call("geoSelection", this, ui.item.label, selectedGeoID, "searchbox");
        },
        // open: function( event, ui ) {
        //     d3.select("#magnifyGlass").style("visibility", "hidden");
        // },
        // close: function( event, ui ) {
        //     d3.select("#magnifyGlass").style("visibility", "visible");
        // }
    });

    dispatch.on("viewChange.searchbox", function(view) {
        // clear searchbox contents
        $("#locationSearch").val("");

        // update placeholder text
        $("#locationSearch").attr("placeholder", "Search by name" + (view === "PC" ? " or postal code" : ""));

        // update search data
        $("#locationSearch").autocomplete({
            // source: search_data.filter(function(d) { return d.search_level === view; })
            source: function( request, response) {
                var matcher = new RegExp( $.ui.autocomplete.escapeRegex( request.term.replace(/\s/g, "") ), "i" ); // create a regex after stripping out any spaces in the search term
                response( $.grep( search_data.filter(function(d) { return d.search_level === view; }), function( value ) {
                    value = value.label || value.value || value;
                    return matcher.test( value ) || matcher.test( value.replace(/\s/g, "") ); // make matches space-insensitive
                }) );
            }
        });
    });

    dispatch.on("geoSelection.searchbox", function(selected_geo_name, selected_geo_id, source) {
        $("#locationSearch").val(selected_geo_name);
    });
});

dispatch.on("load.map", function(index_data, search_data, pcs_bboxes, regions_bboxes, mostRecentQuarter, mostRecentYear) {
    d3.select(".findYourScore .mostRecentQuarter").text(mostRecentQuarter + " " + mostRecentYear);

    // Filter data to the most recent quarter of data
    // since we only need most recent data for this part of the tool
    var most_recent_qtr_data = index_data.filter(function(d) { return d.quarter === mostRecentQuarter && d.year === mostRecentYear; });

    initMap(most_recent_qtr_data);

    var data = makeData(most_recent_qtr_data, "National", "");

    var width = d3.select("#panelIndexChart").node().getBoundingClientRect().width,
        margins = {
            top: 10,
            right: 12,
            bottom: 40,
            left: 5
        };

    var stickChartConfig = {
        width: width,
        height: 80,
        margins: {
            top: 10,
            right: 12,
            bottom: 40,
            left: 5
        },
        stickWidth: 1,
        stickRadius: 0
    };

    var range = d3.extent(most_recent_qtr_data, function(d) { return d["financial_vulnerability_index"]; });

    makeStickChart("panelIndexChart", "financial_vulnerability_index", data, range, stickChartConfig);
    populateComponentsPanel(data, "National");

    dispatch.on("viewChange.map", function(view) {
        // when the user switches to a new view, update the map to show that view
        // and reset the charts to only show the UK average
        if(view === "PC") {
            map.setLayoutProperty("PC-fill", "visibility", "visible");
            map.setLayoutProperty("PC-borders", "visibility", "visible");
            map.setLayoutProperty("PC-hover-borders", "visibility", "visible");
            map.setLayoutProperty("Region-fill", "visibility", "none");
            map.setLayoutProperty("Region-borders", "visibility", "none");
            map.setLayoutProperty("Region-hover-borders", "visibility", "none");
        }
        else {
            map.setLayoutProperty("PC-fill", "visibility", "none");
            map.setLayoutProperty("PC-borders", "visibility", "none");
            map.setLayoutProperty("PC-hover-borders", "visibility", "none");
            map.setLayoutProperty("Region-fill", "visibility", "visible");
            map.setLayoutProperty("Region-borders", "visibility", "visible");
            map.setLayoutProperty("Region-hover-borders", "visibility", "visible");
        }

        var data = makeData(most_recent_qtr_data, "National", "");

        updateStickChart("panelIndexChart", "financial_vulnerability_index", data, stickChartConfig);
        populateComponentsPanel(data, "National");
    });

    dispatch.on("geoSelection.map", function(selected_geo_name, selected_geo_id, source) {
        var bounds = (view === "PC") ? pcs_bboxes[selected_geo_id]["bounds"] : regions_bboxes[selected_geo_id]["bounds"];
        zoomIn(bounds);

        var data = makeData(most_recent_qtr_data, view, selected_geo_id);

        updateStickChart("panelIndexChart", "financial_vulnerability_index", data, stickChartConfig);
        populateComponentsPanel(data, view);
    });

    dispatch.on("mapMouseover.map", function(hovered_geo_id) {
        var data = makeData(most_recent_qtr_data, view, hovered_geo_id);

        updateStickChart("panelIndexChart", "financial_vulnerability_index", data, stickChartConfig);
        populateComponentsPanel(data, view);
    });

    dispatch.on("mapMouseout.map", function() {
        // if clicked_geo_id is not null (i.e., a geo was searched for or clicked on in the map),
        // populate the Financial Distress Index and Component Scores sections with that geo's info
        // otherwise, populate those parts with national data only
        if(selectedGeoID) {
            var data = makeData(most_recent_qtr_data, view, selectedGeoID);
            updateStickChart("panelIndexChart", "financial_vulnerability_index", data, stickChartConfig);
            populateComponentsPanel(data, view);
        }
        else {
            var data = makeData(most_recent_qtr_data, "National", "");
            updateStickChart("panelIndexChart", "financial_vulnerability_index", data, stickChartConfig);
            populateComponentsPanel(data, "National");
        }
    });

    dispatch.on("resize.map", function() {
        var width = d3.select("#panelIndexChart").node().getBoundingClientRect().width;

        stickChartConfig['width'] = width;

        resizeStickChart("panelIndexChart", "financial_vulnerability_index", range, stickChartConfig);
    })
});

dispatch.on("load.componentsCharts", function(index_data, search_data, pcs_bboxes, regions_bboxes, mostRecentQuarter, mostRecentYear) {
    var fviChartConfig = {
        width: d3.select("#financialVulnerabilityIndexChart").node().getBoundingClientRect().width,
        margins: {
            top: 20,
            right: 17,
            bottom: 40,
            left: 25
        },
        aspectWidth: 3,
        aspectHeight: 3,
        ticksY: 5
    }

    var componentChartConfig = {
        width: d3.select("#consumersDefaultChart").node().getBoundingClientRect().width,
        margins: {
            top: 20,
            right: 12,
            bottom: 40,
            left: 30
        },
        aspectWidth: 3,
        aspectHeight: 2.24,
        ticksY: 4
    }

    // Filter data to the series we need and then Nest
    var filteredData = makeData(index_data, "National", "");

    makeLineChart("financialVulnerabilityIndexChart", "financial_vulnerability_index", filteredData, fviChartConfig);
    makeLineChart("consumersDefaultChart", "share_of_lowell_consumers_in_default", filteredData, componentChartConfig);
    makeLineChart("socialBenefitsChart", "share_claiming_social_benefits", filteredData, componentChartConfig);
    makeLineChart("subprimeLendingChart", "share_with_subprime_lending", filteredData, componentChartConfig);
    makeLineChart("creditUseChart", "average_credit_use", filteredData, componentChartConfig);

    // For the stick chart, filter data down to just the latest quarter
    var stickChartData = filteredData.filter(function(d) { return d.quarter === mostRecentQuarter && d.year === mostRecentYear; });

    var stickChartConfig = {
        width: d3.select("#emergencySavingsChart").node().getBoundingClientRect().width,
        height: 60,
        margins: {
            top: 0,
            right: 12,
            bottom: 40,
            left: 5
        },
        stickWidth: 1,
        stickRadius: 0
    };

    var rangeEmergencySavings = d3.extent(index_data, function(d) { return d["share_without_emergency_savings"]; });
    var rangeAltFinancialProducts = d3.extent(index_data, function(d) { return d["share_using_alternative_financial_products"]; });

    makeStickChart("emergencySavingsChart", "share_without_emergency_savings", stickChartData, rangeEmergencySavings, stickChartConfig);
    makeStickChart("altFinancialProductsChart", "share_using_alternative_financial_products", stickChartData, rangeAltFinancialProducts, stickChartConfig);

    populateLegend(stickChartData);

    dispatch.on("viewChange.componentsCharts", function(view) {
        // when the user switches to a new view, reset the charts to only show the UK average
        filteredData = makeData(index_data, "National", "");

        updateLineChart("financialVulnerabilityIndexChart", "financial_vulnerability_index", filteredData, fviChartConfig);
        updateLineChart("consumersDefaultChart", "share_of_lowell_consumers_in_default", filteredData, componentChartConfig);
        updateLineChart("socialBenefitsChart", "share_claiming_social_benefits", filteredData, componentChartConfig);
        updateLineChart("subprimeLendingChart", "share_with_subprime_lending", filteredData, componentChartConfig);
        updateLineChart("creditUseChart", "average_credit_use", filteredData, componentChartConfig);

        // subset data to most recent quarter for the stick charts
        stickChartData = filteredData.filter(function(d) { return d.quarter === mostRecentQuarter && d.year === mostRecentYear; });

        updateStickChart("emergencySavingsChart", "share_without_emergency_savings", stickChartData, stickChartConfig);
        updateStickChart("altFinancialProductsChart", "share_using_alternative_financial_products", stickChartData, stickChartConfig);

        populateLegend(stickChartData);
    });

    dispatch.on("geoSelection.componentsCharts", function(selected_geo_name, selected_geo_id, source) {
        filteredData = makeData(index_data, view, selected_geo_id);

        updateLineChart("financialVulnerabilityIndexChart", "financial_vulnerability_index", filteredData, fviChartConfig);
        updateLineChart("consumersDefaultChart", "share_of_lowell_consumers_in_default", filteredData, componentChartConfig);
        updateLineChart("socialBenefitsChart", "share_claiming_social_benefits", filteredData, componentChartConfig);
        updateLineChart("subprimeLendingChart", "share_with_subprime_lending", filteredData, componentChartConfig);
        updateLineChart("creditUseChart", "average_credit_use", filteredData, componentChartConfig);

        stickChartData = filteredData.filter(function(d) { return d.quarter === mostRecentQuarter && d.year === mostRecentYear; });

        updateStickChart("emergencySavingsChart", "share_without_emergency_savings", stickChartData, stickChartConfig);
        updateStickChart("altFinancialProductsChart", "share_using_alternative_financial_products", stickChartData, stickChartConfig);

        populateLegend(stickChartData);
    });

    dispatch.on("resize.componentsCharts", function() {
        fviChartConfig['width'] =  d3.select("#financialVulnerabilityIndexChart").node().getBoundingClientRect().width;
        componentChartConfig['width'] = d3.select("#consumersDefaultChart").node().getBoundingClientRect().width;

        resizeLineChart("financialVulnerabilityIndexChart", "financial_vulnerability_index", filteredData, fviChartConfig);
        resizeLineChart("consumersDefaultChart", "share_of_lowell_consumers_in_default", filteredData, componentChartConfig);
        resizeLineChart("socialBenefitsChart", "share_claiming_social_benefits", filteredData, componentChartConfig);
        resizeLineChart("subprimeLendingChart", "share_with_subprime_lending", filteredData, componentChartConfig);
        resizeLineChart("creditUseChart", "average_credit_use", filteredData, componentChartConfig);

        stickChartConfig['width'] = d3.select("#emergencySavingsChart").node().getBoundingClientRect().width;

        resizeStickChart("emergencySavingsChart", "share_without_emergency_savings", rangeEmergencySavings, stickChartConfig);
        resizeStickChart("altFinancialProductsChart", "share_using_alternative_financial_products", rangeAltFinancialProducts, stickChartConfig);
    });
});

function makeData(full_dataset, view, geo_id) {
    var data = [];
    var nationalData = full_dataset.filter(function(d) { return d.geo === "National"; });

    if(view === "PC") {
        var pcData = full_dataset.filter(function(d) { return d.geo_id === geo_id; });
        var region_id = pcData[0].country_or_region_id;
        var regionData = full_dataset.filter(function(d) { return d.geo_id === region_id; });
        return data.concat(pcData, regionData, nationalData);
    }
    else if(view === "Region") {
        var regionData = full_dataset.filter(function(d) { return d.geo_id === geo_id; });
        return data.concat(regionData, nationalData);
    }

    return nationalData;
}

function makeLineChart(elementID, metric, data, config) {
    var isMobile = config.width < 400;

    var chartIndent = 0;

    var axisTickExtender = 20;

    var roundTicksFactor = 5;

    var width = config.width - config.margins['left'] - config.margins['right'],
        height = Math.ceil((config.width * config.aspectHeight) / config.aspectWidth) - config.margins['top'] - config.margins['bottom'];

    var dataSeries = d3.nest()
        .key(function(d) { return d.geo; })
        .entries(data);

    var min = d3.min(data, function(d) {
        return Math.floor(d[metric] / roundTicksFactor) * roundTicksFactor;
    });

    var max = d3.max(data, function(d) {
        return Math.ceil(d[metric] / roundTicksFactor) * roundTicksFactor;
    })

    var xScale = d3.scaleTime()
        .domain(d3.extent(data.map(function(d) { return d.date; })))
        .range([ 0, width ]);

    var yScale = d3.scaleLinear()
        // .domain(d3.extent(data.map(function(d) { return d[metric]; }))).nice()
        .domain([ min, max ])
        .range([ height, 0 ]);

    var chartElement = d3.select("#" + elementID)
        .append('svg')
            .attr('width', config.width)
            .attr('height', height + config.margins['top'] + config.margins['bottom'])
        .append('g')
            .attr('transform', 'translate(' + config.margins['left'] + ',' + config.margins['top'] + ')');

    // Add chart background for the FVI chart
    if(elementID === "financialVulnerabilityIndexChart") {
        var paddingTop = 20
        chartElement.append("rect")
            .attr("class", "chartBackground")
            .attr("x",  -config.margins['left'])
            .attr("y", -paddingTop)
            .attr("width", config.width)
            .attr("height", height + paddingTop);
    }

    var yAxis = function(g) {
        g.call(d3.axisLeft(yScale)
            .ticks(config.ticksY)
            .tickSize(-width - axisTickExtender)
            )
        .call(function(g) {
                g.selectAll('.domain')
                    .remove() }
            );
    }

    var xAxis = function(g) {
        g.attr('transform', "translate(" + chartIndent + "," + height + ")")
        .call(d3.axisBottom(xScale)
            .tickSizeOuter(0)
            .tickFormat(isMobile ? quarterFormatterShort : quarterFormatterLong))
        .call(function(g) {
            g.selectAll('.domain')
                .remove(); }
        )
        .append('path')
        .attr('class', 'domain')
        .attr('d', "M" + -config.margins['left'] + ",0H" + (width + config.margins['right']) ); // draw the x-axis line so it extends into the chart margins
    }

    // Render axes
    chartElement.append('g')
        .attr('class', 'y axis')
        .call(yAxis);

    chartElement.append('g')
        .attr('class', 'x axis')
        .call(xAxis);

    var numTicksX = d3.selectAll('#' + elementID + ' .x.axis .tick')._groups[0].length;

    d3.selectAll('#' + elementID + ' .x.axis .tick')._groups[0].forEach(function(tick, i){
        if(i === 0) {
            var selection = d3.select(tick)
            selection.append('text')
                .text('Q3')
                .attr('class', 'qtr-label')
                .attr('dy',3)
                .attr('y',30)
                .attr('fill','#000000')
        }
        if((elementID === "financialVulnerabilityIndexChart") && (i % 4 === 2)) {
            var selection = d3.select(tick)
            selection.append('text')
                .text('Q1')
                .attr('class', 'qtr-label')
                .attr('dy',3)
                .attr('y',30)
                .attr('fill','#000000')
        }
        if(i === numTicksX - 1) {
            var selection = d3.select(tick)
            selection.append('text')
                .text('Q2')  // need to update this number when new data are added
                .attr('class', 'qtr-label')
                .attr('dy',3)
                .attr('y',30)
                .attr('fill','#000000')
        }
    })

    // Render lines
    var line = d3.line()
        .defined(function(d) { return !isNaN(d[metric]); })
        .curve(d3.curveLinear)
        .x(function(d) { return xScale(d["date"]); })
        .y(function(d) { return yScale(d[metric]); });

    var lines = chartElement.append("g")
        .attr("class", "lines")
        .selectAll('.line')
        .data(dataSeries, function(d) { return d.key; })
        .enter()
        .append("path")
            .attr('class', function(d) { return "line " + d.key; })
            .attr('d', function(d) { return line(d['values']); });

    adjustAxis(elementID, height);
}

function updateLineChart(elementID, metric, data, config) {
    var roundTicksFactor = 5;
    var axisTickExtender = 20;

    var width = config.width - config.margins['left'] - config.margins['right'],
        height = Math.ceil((config.width * config.aspectHeight) / config.aspectWidth) - config.margins['top'] - config.margins['bottom'];

    var min = d3.min(data, function(d) {
        return Math.floor(d[metric] / roundTicksFactor) * roundTicksFactor;
    });

    var max = d3.max(data, function(d) {
        return Math.ceil(d[metric] / roundTicksFactor) * roundTicksFactor;
    });

    var xScale = d3.scaleTime()
        .domain(d3.extent(data.map(function(d) { return d.date; })))
        .range([ 0, width ]);

    var yScale = d3.scaleLinear()
        // .domain(d3.extent(data.map(function(d) { return d[metric]; }))).nice()
        .domain([ min, max ])
        .range([ height, 0 ]);

    d3.selectAll("#" + elementID + " .y.axis")
        .transition()
        // .duration(3000)
        .call(d3.axisLeft(yScale)
                .ticks(config.ticksY)
                .tickSize(-width - axisTickExtender)
            )
        .call(function(g) {
                g.selectAll('.domain')
                    .remove(); }
            )
        .on("end", function() { adjustAxis(elementID, height); });

    var dataSeries = d3.nest()
        .key(function(d) { return d.geo; })
        .entries(data);

    var line = d3.line()
        .defined(function(d) { return !isNaN(d[metric]); })
        .curve(d3.curveLinear)
        .x(function(d) { return xScale(d["date"]); })
        .y(function(d) { return yScale(d[metric]); });

    var lines = d3.select("#" + elementID + " svg g g.lines")
        .selectAll(".line")
        .data(dataSeries, function(d) { return d.key; });

    lines.exit().remove();

    lines.enter()
        .append("path")
            .attr("class", function(d) { return "line " + d.key; })
        .merge(lines)
            .transition()
            .attr("d", function(d) { return line(d.values); });

    // adjustAxis(elementID, height);
}

function resizeLineChart(elementID, metric, data, config) {
    var width = config.width - config.margins['left'] - config.margins['right'],
        height = Math.ceil((config.width * config.aspectHeight) / config.aspectWidth) - config.margins['top'] - config.margins['bottom'];

    var isMobile = config.width < 400;

    var roundTicksFactor = 5;

    var min = d3.min(data, function(d) {
        return Math.floor(d[metric] / roundTicksFactor) * roundTicksFactor;
    });

    var max = d3.max(data, function(d) {
        return Math.ceil(d[metric] / roundTicksFactor) * roundTicksFactor;
    })

    var xScale = d3.scaleTime()
        .domain(d3.extent(data.map(function(d) { return d.date; })))
        .range([ 0, width ]);

    var yScale = d3.scaleLinear()
        // .domain(d3.extent(data.map(function(d) { return d[metric]; }))).nice()
        .domain([ min, max ])
        .range([ height, 0 ]);

    d3.select("#" + elementID + " svg")
        .attr('width', config.width)
        .attr('height', height + config.margins['top'] + config.margins['bottom']);

    if(elementID === "financialVulnerabilityIndexChart") {
        d3.select("#financialVulnerabilityIndexChart rect")
            .attr("x",  -config.margins['left'])
            .attr("y", 0)
            .attr("width", config.width)
            .attr("height", height);
    }

    d3.selectAll("#" + elementID + " .y.axis")
        .transition()
        // .duration(3000)
        .call(d3.axisLeft(yScale)
            .ticks(config.ticksY)
            .tickSize(-width)
            )
        .call(function(g) {
                g.selectAll('.domain')
                    .remove(); }
            );

    d3.selectAll("#" + elementID + " .x.axis")
        .transition()
        .attr('transform', "translate(0," + height + ")")
        .call(d3.axisBottom(xScale)
            .tickSizeOuter(0)
            .tickFormat(isMobile ? quarterFormatterShort : quarterFormatterLong)
        )
        .call(function(g) {
            g.selectAll('.domain')
                .remove(); }
        );

    d3.selectAll("#" + elementID + " .x.axis")
        .append('path')
        .attr('class', 'domain')
        .attr('d', "M" + -config.margins['left'] + ",0H" + (width + config.margins['right']) );

    var line = d3.line()
        .defined(function(d) { return !isNaN(d[metric]); })
        .curve(d3.curveLinear)
        .x(function(d) { return xScale(d["date"]); })
        .y(function(d) { return yScale(d[metric]); });

    d3.selectAll("#" + elementID + " .line")
        .transition()
        .attr("d", function(d) { return line(d["values"]); });

    adjustAxis(elementID, height);
}

function makeStickChart(elementID, metric, data, range, config) {
    var width = config.width - config.margins['left'] - config.margins['right'],
        height = config.height - config.margins['top'] - config.margins['bottom'];

    // make the top "table" of numbers and place names
    var table = d3.select("#" + elementID)
        .append("div")
        .attr("class", "container");

    var columns = table.selectAll(".column")
        .data(data)
        .enter()
        .append("div")
            .attr("class", function(d) { return "column " + d.geo; });

    columns.append("span")
        .attr("class", "number")
            .text(function(d) { return metric === "financial_vulnerability_index" ? COMMAFORMAT(d[metric]) : COMMAFORMAT(d[metric]) + "%"; });

    columns.append("div")
        .attr("class", "geoName")
            .text(function(d) { return d.geo_name; });

    // make stick chart
    var xScale = d3.scaleLinear()
        .domain([0, 100])
        .range([0, width]);

    var chartElement = d3.select("#" + elementID)
        .append("svg")
            .attr('width', config.width)
            .attr('height', config.height)
        .append('g')
            .attr('transform', 'translate(' + config.margins['left'] + ',' + config.margins['top'] + ')');

    var xAxis = function(g) {
        g.attr('transform', "translate(0," + height + ")")
        .call(d3.axisBottom(xScale)
            .ticks(5)
            .tickSizeOuter(0));
    }

    var sticks = chartElement.selectAll(".stick")
        .data(data, function(d) { return d.geo; })
        .enter()
        .append("rect")
            .attr("class", function(d) { return "stick " + d.geo ; })
            .attr("x", function(d) { return xScale(d[metric]) - 2; }) // "center" the rectangle
            .attr("width", config.stickWidth)
            .attr("y", 0)
            .attr("height", height)
            .attr("rx", config.stickRadius);

    // Shade in range of scores on the x-axis
    var scoreRange = chartElement.append('g')
        .attr('class', 'scoreRange')
        .attr('transform', 'translate(0,' + height + ')');

    scoreRange.append('rect')
        .attr('x', xScale(range[0]))
        .attr('y', 0)
        .attr('width', xScale(range[1] - range[0]))
        .attr('height', 26)
        .attr('rx', 2);

    scoreRange.append('text')
        .attr('x', Math.max(53, ( xScale(range[0]) + xScale(range[1]) ) / 2 ))
        .attr('y', 40)
        .text('Range of Scores');

    chartElement.append('g')
        .attr('class', 'x axis')
        .call(xAxis);
}

function updateStickChart(elementID, metric, data, config) {
    var width = config.width - config.margins['left'] - config.margins['right'],
        height = config.height - config.margins['top'] - config.margins['bottom'];

    var columns = d3.select("#" + elementID + " .container")
        .selectAll(".column")
        .data(data);

    columns.exit().remove();

    var columnsEnter = columns.enter()
        .append("div")

    columnsEnter.append("span")
        .attr("class", "number");

    columnsEnter.append("div")
        .attr("class", "geoName");

    columnsEnter = columnsEnter.merge(columns)
        .attr("class", function(d) { return "column " + d.geo; });

    columnsEnter.select(".number")
        .text(function(d) { return metric === "financial_vulnerability_index" ? COMMAFORMAT(d[metric]) : COMMAFORMAT(d[metric]) + "%"; });

    columnsEnter.select(".geoName")
        .text(function(d) { return d.geo_name; });

    var xScale = d3.scaleLinear()
        .domain([0, 100])
        .range([0, width]);

    var sticks = d3.select("#" + elementID + " svg g")
        .selectAll(".stick")
        .data(data, function(d) { return d.geo; });

    sticks.exit().remove();

    sticks.enter()
        .append("rect")
            .attr("class", function(d) { return "stick " + d.geo; })
        .merge(sticks)
        .transition()
            .attr("class", function(d) { return "stick " + d.geo ; })
            .attr("x", function(d) { return xScale(d[metric]) - 2; })
            .attr("width", config.stickWidth)
            .attr("y", 0)
            .attr("height", height)
            .attr("rx", config.stickRadius);
}

function resizeStickChart(elementID, metric, range, config) {
    var width = config.width - config.margins['left'] - config.margins['right'],
        height = config.height - config.margins['top'] - config.margins['bottom'];

    var xScale = d3.scaleLinear()
        .domain([0, 100])
        .range([0, width]);

    d3.select("#" + elementID + " svg")
        .attr('width', config.width)
        .attr('height', config.height);

    d3.selectAll("#" + elementID + " .x.axis")
        .transition()
        .attr('transform', "translate(0," + height + ")")
        .call(d3.axisBottom(xScale)
            .ticks(5)
            .tickSizeOuter(0));

    d3.select('#' + elementID + ' .scoreRange rect')
        .attr('x', xScale(range[0]))
        .attr('width', xScale(range[1] - range[0]));

    d3.select('#' + elementID +  ' .scoreRange text')
        .attr('x', Math.max(53, ( xScale(range[0]) + xScale(range[1]) ) / 2 ));

    d3.selectAll("#" + elementID + " .stick")
            .transition()
            .attr("x", function(d) { return xScale(d[metric]) - 2; });
}

function populateLegend(data) {
    // populate the legend that appears below the Financial Vulnerability
    // Index chart in the Go Deeper section
    var legend = d3.select(".components .legend");

    if(data.length === 1) {
        legend.select(".legendEntry.pc").classed("hidden", true);
        legend.select(".legendEntry.region").classed("hidden", true);
    }
    else if(data.length === 2) {
        legend.select(".legendEntry.pc").classed("hidden", true);
        legend.select(".legendEntry.region").classed("hidden", false);

        legend.select(".legendLabel.region").text(data.filter(function(d) { return d.geo === "Region"; })[0]["geo_name"]);
    }
    else {
        legend.select(".legendEntry.pc").classed("hidden", false);
        legend.select(".legendEntry.region").classed("hidden", false);

        legend.select(".legendLabel.pc").text(data.filter(function(d) { return d.geo === "PC"; })[0]["geo_name"]);
        legend.select(".legendLabel.region").text(data.filter(function(d) { return d.geo === "Region"; })[0]["geo_name"]);
    }
}

function populateComponentsPanel(data, view) {
    // show or hide bars based on which geo is selected
    if(data.length === 1) {
        d3.selectAll(".componentScores .chart .PC").style("display", "none");
        d3.selectAll(".componentScores .chart .Region").style("display", "none");
    }
    else if(data.length === 2) {
        d3.selectAll(".componentScores .chart .PC").style("display", "none");
        d3.selectAll(".componentScores .chart .Region").style("display", "block");
    }
    else {
        d3.selectAll(".componentScores .chart .PC").style("display", "block");
        d3.selectAll(".componentScores .chart .Region").style("display", "block");
    }

    var metricElementMap = {
        inDefault: "share_of_lowell_consumers_in_default",
        socialBenefits: "share_claiming_social_benefits",
        subprimeLending: "share_with_subprime_lending",
        creditUse: "average_credit_use",
        emergencySavings: "share_without_emergency_savings",
        altFinancialProducts: "share_using_alternative_financial_products"
    }

    Object.keys(metricElementMap).forEach(function(element) {
        // the numbers in the table are for the most specific geography selected
        populateTableNumbers(element, view);

        // adjust length of bars
        d3.select("." + element + " .National")
            .style("width", data.filter(function(d) { return d.geo === "National"; })[0][metricElementMap[element]] + "%");

        if(data.length === 3) {
            d3.select("." + element + " .PC")
                .style("width", data.filter(function(d) { return d.geo === "PC"; })[0][metricElementMap[element]] + "%");
        }

        if(data.length >= 2) {
            d3.select("." + element + " .Region")
                .style("width", data.filter(function(d) { return d.geo === "Region"; })[0][metricElementMap[element]] + "%");
        }
    });

function populateTableNumbers(element, view) {
    d3.select("." + element + " .number > span")
        .attr("class", "number " + view + "Number")
        .text(COMMAFORMAT(data.filter(function(d) { return d.geo === view; })[0][metricElementMap[element]]) + "%");
    }

    d3.selectAll(".componentScores .chart div").on("mouseover", function() {
        var hoveredView = d3.select(this).attr("class");

        // populate table with numbers corresponding to the geo level of the bar that's hovered over
        // (i.e., if hovering over the region bar, show region values in the table)
        Object.keys(metricElementMap).forEach(function(element) {
            populateTableNumbers(element, hoveredView);
        });

    });

    d3.selectAll(".componentScores .chart div").on("mouseout", function() {
        Object.keys(metricElementMap).forEach(function(element) {
            populateTableNumbers(element, view);
        });
    });
}

function initMap(index_data){

    mapboxgl.accessToken = 'pk.eyJ1IjoidXJiYW5pbnN0aXR1dGUiLCJhIjoiTEJUbmNDcyJ9.mbuZTy4hI_PWXw3C3UFbDQ';

    map = new mapboxgl.Map({
        attributionControl: false,
        container: 'map',
        style: 'mapbox://styles/urbaninstitute/ckjkfrl3g1jqk19mee5uwvubf',
        center: [-2.5, 54.356],
        zoom: 4.5,
        maxZoom: 11,
        minZoom: 3.5
    });

    var hoverGeoID = null, // track which geo is mousedover
        clickedGeoID = null,
        hoverGeoID_orig,
        clickedGeoID_orig;

    map.on('load', function() {

        // make the tract outlines in the *-hover-borders layer transparent initially
        // as geos are hovered over, that geo's border's opacity will be set to 1
        map.setPaintProperty(
            'PC-hover-borders',
            'line-opacity',
            [
                'case',
                ['boolean', ['feature-state', 'highlight'], false],
                1,
                0
            ]
        );

        map.setPaintProperty(
            'Region-hover-borders',
            'line-opacity',
            [
                'case',
                ['boolean', ['feature-state', 'highlight'], false],
                1,
                0
            ]
        );

        // disable map rotation using right click + drag
        map.dragRotate.disable();

        // disable map rotation using touch rotation gesture
        map.touchZoomRotate.disableRotation();

        // on tablet and phone screens, disable map zoom when using scroll
        if(d3.select(".container").node().getBoundingClientRect().width < 1000) {
            map.scrollZoom.disable();
        }

        // hover behavior adapted from: https://docs.mapbox.com/help/tutorials/create-interactive-hover-effects-with-mapbox-gl-js/
        // also a good resource: https://blog.mapbox.com/going-live-with-electoral-maps-a-guide-to-feature-state-b520e91a22d
        map.on('mousemove', 'PC-fill', function(e) { // detect mousemove on the fill layer instead of stroke layer so correct geo is highlighted

            map.getCanvas().style.cursor = 'pointer';

            // Check whether features exist
            if (e.features.length > 0) {

                // If geoID for the hovered feature is not null,
                // use removeFeatureState to reset to the default behavior
                if (hoverGeoID) {
                    map.removeFeatureState({
                        source: 'composite',  // can find what the source and sourceLayer are from console logging e.features[0]["layer"]
                        sourceLayer: 'pcsid',
                        id: hoverGeoID
                    });
                }

                hoverGeoID = e.features[0]["id"]; // this is the Mapbox numeric id
                hoverGeoID_orig = e.features[0]["properties"]["geo_id"]; // this is the ID that links to the rest of the data

                // When the mouse moves over the tract-hover-strokes layer, update the
                // feature state for the feature under the mouse
                map.setFeatureState({
                    source: 'composite',
                    sourceLayer: 'pcsid',
                    id: hoverGeoID
                },
                {
                    highlight: true
                });

                dispatch.call("mapMouseover", this, hoverGeoID_orig);

                // if a geo has been clicked on, make sure it is still highlighted
                if(clickedGeoID) {
                    map.setFeatureState({
                        source: 'composite',
                        sourceLayer: 'pcsid',
                        id: clickedGeoID
                    }, {
                        highlight: true
                    });
                }
            }
        });

        map.on("mouseleave", "PC-fill", function() {

            if (hoverGeoID) {
                map.setFeatureState({
                    source: 'composite',
                    sourceLayer: 'pcsid',
                    id: hoverGeoID
                }, {
                    highlight: false
                });
            }

            hoverGeoID = null;

            // if a geo has been clicked on, keep it highlighted
            if(clickedGeoID) {
                map.setFeatureState({
                    source: 'composite',
                    sourceLayer: 'pcsid',
                    id: clickedGeoID
                }, {
                    highlight: true
                });
            }

            dispatch.call("mapMouseout", this);

            // Reset the cursor style
            map.getCanvas().style.cursor = '';
        });

        map.on("click", "PC-fill", function(e) {

            if(e.features.length > 0) {
                // stop highlighting any previously clicked on tracts
                if (clickedGeoID) {
                    map.removeFeatureState({
                        source: 'composite',
                        sourceLayer: 'pcsid',
                        id: clickedGeoID
                    });
                }

                clickedGeoID = e.features[0].id;
                clickedGeoID_orig = e.features[0].properties["geo_id"];
                clickedGeoName = e.features[0].properties["PCON17NM"];
                selectedGeoID = clickedGeoID_orig;

                map.setFeatureState({
                    source: 'composite',
                    sourceLayer: 'pcsid',
                    id: clickedGeoID
                },
                {
                    highlight: true
                });

                dispatch.call("geoSelection", this, clickedGeoName, clickedGeoID_orig, "map");
            }
        });

        // repeat above setup for the region layers
        map.on('mousemove', 'Region-fill', function(e) {

            map.getCanvas().style.cursor = 'pointer';

            if (e.features.length > 0) {

                if (hoverGeoID) {
                    map.removeFeatureState({
                        source: 'composite',
                        sourceLayer: 'regionsid',
                        id: hoverGeoID
                    });
                }

                hoverGeoID = e.features[0]["id"];
                hoverGeoID_orig = e.features[0]["properties"]["geo_id"];

                map.setFeatureState({
                    source: 'composite',
                    sourceLayer: 'regionsid',
                    id: hoverGeoID
                },
                {
                    highlight: true
                });

                dispatch.call("mapMouseover", this, hoverGeoID_orig);

                if(clickedGeoID) {
                    map.setFeatureState({
                        source: 'composite',
                        sourceLayer: 'regionsid',
                        id: clickedGeoID
                    }, {
                        highlight: true
                    });
                }
            }
        });

        map.on("mouseleave", "Region-fill", function() {

            if (hoverGeoID) {
                map.setFeatureState({
                    source: 'composite',
                    sourceLayer: 'regionsid',
                    id: hoverGeoID
                }, {
                    highlight: false
                });
            }

            hoverGeoID = null;

            if(clickedGeoID) {
                map.setFeatureState({
                    source: 'composite',
                    sourceLayer: 'regionsid',
                    id: clickedGeoID
                }, {
                    highlight: true
                });
            }

            dispatch.call("mapMouseout", this);

            map.getCanvas().style.cursor = '';
        });

        map.on("click", "Region-fill", function(e) {

            if(e.features.length > 0) {
                if (clickedGeoID) {
                    map.removeFeatureState({
                        source: 'composite',
                        sourceLayer: 'regionsid',
                        id: clickedGeoID
                    });
                }

                clickedGeoID = e.features[0].id;
                clickedGeoID_orig = e.features[0].properties["geo_id"];
                clickedGeoName = e.features[0].properties["nuts118nm"];
                selectedGeoID = clickedGeoID_orig;

                map.setFeatureState({
                    source: 'composite',
                    sourceLayer: 'regionsid',
                    id: clickedGeoID
                },
                {
                    highlight: true
                });

                dispatch.call("geoSelection", this, clickedGeoName, clickedGeoID_orig, "map");
            }
        });

        function waitForLoad(){
            if(map.loaded()) {
                // unhide charts and maps and hide the loading gif after data has loaded
                // and tool has populated
                // this seems to remove the loading gif a little before the map has rendered though
                d3.selectAll("section.loading").classed("loading", false);
                d3.select("#loadingGif").classed("hidden", true);
            }
            else setTimeout(waitForLoad, 300);
        }

        waitForLoad();
    });

    map.addControl(new mapboxgl.NavigationControl({"showCompass": false}), "bottom-right");

    dispatch.on("viewChange.mapboxMap", function(view) {
        // remove any highlighted PCs or regions when the view is changed
        // and reset clickedGeoID to be null
        map.setFeatureState({
            source: 'composite',
            sourceLayer: 'pcsid',
            id: clickedGeoID
        }, {
            highlight: false
        });

        map.setFeatureState({
            source: 'composite',
            sourceLayer: 'regionsid',
            id: clickedGeoID
        }, {
            highlight: false
        });

        clickedGeoID = null;
    });

    dispatch.on("geoSelection.mapboxMap", function(selected_geo_name, selected_geo_id, source) {
        // first clear any previous highlighting (i.e., if the user previously clicked on the map)
        map.setFeatureState({
            source: 'composite',
            sourceLayer: 'pcsid',
            id: clickedGeoID
        }, {
            highlight: false
        });

        map.setFeatureState({
            source: 'composite',
            sourceLayer: 'regionsid',
            id: clickedGeoID
        }, {
            highlight: false
        });

        // get the mapbox ID for the selected geo
        clickedGeoID = index_data.filter(function(d) { return d.geo_id === selected_geo_id})[0]["mapbox_id"];

        if(view === "PC") {
            map.setFeatureState({
                source: 'composite',
                sourceLayer: 'pcsid',
                id: clickedGeoID
            }, {
                highlight: true
            });
        }
        else {
            map.setFeatureState({
                source: 'composite',
                sourceLayer: 'regionsid',
                id: clickedGeoID
            }, {
                highlight: true
            });
        }
    });
}

function zoomIn(bounds) {
    map.fitBounds(
        bounds,
        {
            "padding": 20,
            "duration": 900,
            "essential": true, // If true, then the animation is considered essential and will not be affected by prefers-reduced-motion .
        }
    );
}

var quarterFormatterLong = function(date, i) {
    // display the 4-digit year for Q1, nothing for all other quarters
    // except the first and last quarters of data
    // code from here: https://stackoverflow.com/questions/26921414/d3js-x-axis-data-by-quarter-sub-grouped-by-year

    var year = date.getFullYear(),
        month = date.getMonth(),
        quarter = Math.ceil(month / 3 ) + 1;

    if(quarter === 1 | i === 0 || i === 11) {
        return year;
    }
}

var quarterFormatterShort = function(date, i) {
    // display the 2-digit year for Q1, nothing for all other quarters
    // except the first and last quarters of data
    // code from here: https://stackoverflow.com/questions/26921414/d3js-x-axis-data-by-quarter-sub-grouped-by-year

    var year = date.getFullYear(),
        month = date.getMonth(),
        quarter = Math.ceil(month / 3 ) + 1;

    if(quarter === 1 | i === 0 || i === 11) {
        return "'" + year % 2000;
    }
}

d3.selection.prototype.moveToFront = function() {
    return this.each(function(){
        this.parentNode.appendChild(this);
    });
};


function adjustAxis(elementID, height){

    //JBC here with my gross code!
  var yAxisSelection = d3.selectAll('#' + elementID + ' .y.axis')
  yAxisSelection.selectAll('.tick line').attr('x1', -25 )
  yAxisSelection.selectAll('.tick text').attr('y', -10)

    // if the lowest tick mark is too close to the x-axis to fit the
    // tick label without overlapping, delete it
    // THIS DOES NOT WORK
    // d3.selectAll('#' + elementID + ' .y.axis .tick')._groups[0].forEach(function(tick, i){
    //     console.log(d3.select(tick).attr('transform'));
    //     var tickTranslate = d3.select(tick).attr('transform');
    //     var tickTranslateY = +tickTranslate.split(',')[1].split(')')[0]; // couldn't find an easy way to get the translation coordinates
    //     if(height - tickTranslateY <= 13) {
    //         d3.select(tick).style('display', 'none')
    //     }
    // });
}

// EVENT LISTENERS
d3.selectAll("input[name='geoType']")
    .on("click", function() { view = getSelectedView();
                              selectedGeoID = null;
                              dispatch.call("viewChange", this, view); });

// d3.select("#locationSearch").on("click", function() { $("#locationSearch").val(""); });

function getSelectedView() {
    return d3.select("input[name='geoType']:checked").node().value;
}

window.addEventListener("resize", redraw);

function redraw() {
    dispatch.call("resize", this);
}
