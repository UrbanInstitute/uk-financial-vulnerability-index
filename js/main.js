// variables to catch "initial" state
var view = "PC";
var selectedGeoID = null;
var selectedRegionFilter = "all"; // get the region/country user is filtering the change over time line chart with

var data,
    searchData;

var dispatch = d3.dispatch("load", "viewChange", "geoSelection", "regionFilterChange", "mapMouseover", "mapMouseout");

var COMMAFORMAT = d3.format(",.1f");

var isMobile = false,
    aspectWidth = isMobile ? 3 : 6,
    aspectHeight = isMobile ? 2 : 4;

d3.queue()
    .defer(d3.csv, "data/index_data.csv")
    .defer(d3.json, "data/pcs_bboxes.json")
    .defer(d3.json, "data/regions_bboxes.json")
    .defer(d3.csv, "data/search_data.csv")
.await(function(error, index_data, pcs_bboxes, regions_bboxes, search_data) {

    if(error) throw error;

    index_data.forEach(function(d) {
        d.average_credit_use = +d.average_credit_use,
        d.date = d3.timeParse("%Y-%m-%d")(d.date),
        d.financial_vulnerability_index = +d.financial_vulnerability_index,
        d.share_claiming_social_benefits = +d.share_claiming_social_benefits,
        d.share_of_lowell_consumers_in_default = +d.share_of_lowell_consumers_in_default,
        d.share_using_alternative_financial_products = +d.share_using_alternative_financial_products,
        d.share_with_subprime_lending = +d.share_with_subprime_lending,
        d.share_without_emergency_savings = +d.share_without_emergency_savings,
        d.mapbox_id = +d.mapbox_id
    })

    var mostRecentYear = d3.max(index_data, function(d) { return d.year; });
    var mostRecentQuarter = d3.max(index_data.filter(function(d) { return d.year === mostRecentYear}),
        function(d) { return d.quarter; });

    dispatch.call("load", this, index_data, search_data, pcs_bboxes, regions_bboxes, mostRecentQuarter, mostRecentYear);
});

dispatch.on("load.searchbox", function(index_data, search_data, mostRecentQuarter) {
    $("#locationSearch").autocomplete({
        source: search_data.filter(function(d) { return d.search_level === "PC"; }),
        search: function() {
            if(this.value.length < 4) {  // only display options after at least 4 characters are typed because this dataset is really big
                return false;
            }
        },
        select: function( event, ui ) {
            // console.log(ui.item);
            $("#locationSearch").val(ui.item.label);   // need this so when user clicks on a county name instead of hitting the enter key, the full name is captured (otherwise, only typed letters will get captured)

            selectedGeoID = ui.item.id;
            dispatch.call("geoSelection", this, ui.item.label, selectedGeoID, "searchbox");
        },
        // open: function( event, ui ) {
        //     d3.select("#magnifyGlass").style("visibility", "hidden");
        // },
        // close: function( event, ui ) {
        //     d3.select("#magnifyGlass").style("visibility", "visible");
        // }
    });

    dispatch.on("viewChange.searchbox", function(view) {
        // clear searchbox contents
        $("#locationSearch").val("");

        // update placeholder text
        $("#locationSearch").attr("placeholder", "Find " + (view === "PC" ? "constituencies" : "region") + " by name or postcode");

        // update search data
        $("#locationSearch").autocomplete({
            source: search_data.filter(function(d) { return d.search_level === view; })
        });
    });

    dispatch.on("geoSelection.searchbox", function(selected_geo_name, selected_geo_id, source) {
        $("#locationSearch").val(selected_geo_name);
    });
});

dispatch.on("load.hairChart", function(index_data, search_data, pcs_bboxes, regions_bboxes, mostRecentQuarter, mostRecentYear) {
    /*
     * Setup
     */
    const width = d3.select("#hairChart").node().getBoundingClientRect().width;

    const margins = {
        top: 10,
        right: 20,
        bottom: 40,
        left: 20
    };

    const ticksY = 5;

    // Mobile
    // if (isMobile) {
    //     ticksY = 5;
    //     margins['right'] = 25;
    // }

    // Calculate actual chart dimensions
    const chartWidth = width - margins['left'] - margins['right'];
    const chartHeight = Math.ceil((width * aspectHeight) / aspectWidth) - margins['top'] - margins['bottom'];

    // Set x-position of the tooltip now that we know the chart width
    d3.select("#hairChart .tooltip").style("left", width + "px");

    // Nest data
    const dataSeries = d3.nest()
        .key(function(d) { return d.geo_name; })
        .entries(index_data);

    /*
     * Create D3 scale objects.
     */
    const xScale = d3.scaleTime()
        .domain(d3.extent(index_data.map(function(d) { return d.date; })))
        .range([ 0, chartWidth ]);

    const yScale = d3.scaleLinear()
        .domain(d3.extent(index_data.filter(function(d) { return d.geo === view; })
                                    .map(function(d) { return d.financial_vulnerability_index; })))
            .nice()
        .range([chartHeight, 0]);

    var lineChartConfig = {
        width: chartWidth,
        height: chartHeight,
        margins: margins,
        ticksY: ticksY,
        xScale: xScale,
        yScale: yScale
    }

    makeLineChart("hairChart", "financial_vulnerability_index", dataSeries, lineChartConfig);

    /*
     * Hide all region lines on initial page load
     */
    d3.selectAll("#hairChart .line.region").classed("invisible", true);

    /*
     * Add voronoi to make line selection easier.
     */
//     var cells = d3.voronoi()
//         .x(function(d) { return xScale(d["date"]); })
//         .y(function(d) { return yScale(d["financial_vulnerability_index"]); })
//         .extent([[-1, -1], [chartWidth + 1, chartHeight + 1]])
//         .polygons(index_data.filter(function(d) { return d.geo === "PC"; }));

//     var voronoi = d3.select("#hairChart svg g").append("g")
//         .attr("class", "voronoi")
//         .selectAll("g")
//         .data(cells.filter(function(d) { return typeof d !== "undefined"; }))
//         .enter()
//         .append("path")
//             .attr("class", "cell")
//             .attr("d", function(d, i) { return "M" + d.join("L") + "Z"; })
//             .on("mouseover", function (d) {
//                 // console.log("mouseover", selectedGeoID);

//                 d3.selectAll("#hairChart .line").classed("highlighted", false);
//                 d3.select("#hairChart .line." + d.data.geo_id).moveToFront();
//                 d3.select("#hairChart .line." + d.data.geo_id).classed('highlighted', true)
//                 populateTooltip(d.data.geo_id);
//             })
//             // .on('mousemove', function (d) {
//             //     chartMousemove(d.point.name);
//             // })
//             .on("mouseout", function (d) {
//                 d3.selectAll("#hairChart .line").classed('highlighted', false);
// // console.log("mouseout", selectedGeoID);
//                 // if a geo has been selected and appears in the chart, populate its tooltip. otherwise, hide the tooltip
//                 if( (selectedGeoID === null) || (d3.select(".line.selected").classed("invisible")) ) {
//                     d3.select("#hairChart .tooltip").classed("hidden", true);
//                 }
//                 else {
//                     populateTooltip(selectedGeoID);
//                 }
//             })
//             .on("mouseleave", function (d) {
// // console.log("mouseleave", selectedGeoID);

//                 d3.selectAll("#hairChart .line").classed('highlighted', false);
//                 // if a geo has been selected, populate its tooltip. otherwise, hide the tooltip
//                 if( (selectedGeoID === null) || (d3.select(".line.selected").classed("invisible")) ) {
//                     d3.select("#hairChart .tooltip").classed("hidden", true);
//                 }
//                 else {
//                     console.log("tooltip should appear");
//                     populateTooltip(selectedGeoID);
//                 }
//             })
//             .on("click", function(d) {
//                 selectedGeoID = d.data.geo_id;
//                 dispatch.call("geoSelection", this, d.data.geo_name, d.data.geo_id, "hairChart");
//             });

    function populateTooltip(geo_id) {
        var mostRecentQuarterData = index_data.filter(function(d) { return d.geo_id === geo_id && d.year === mostRecentYear && d.quarter === mostRecentQuarter; })[0];
        d3.select("#hairChart .tooltip .score").text(mostRecentQuarterData.financial_vulnerability_index);
        d3.select("#hairChart .tooltip .geoName").text(mostRecentQuarterData.geo_name);
        d3.select("#hairChart .tooltip").style("top", yScale(mostRecentQuarterData.financial_vulnerability_index) + "px");
        d3.select("#hairChart .tooltip").classed("hidden", false);
    }

    function updateVoronoi(data) {
        var cells = d3.voronoi()
            .x(function(d) { return xScale(d["date"]); })
            .y(function(d) { return yScale(d["financial_vulnerability_index"]); })
            .extent([[-1, -1], [chartWidth + 1, chartHeight + 1]])
            .polygons(data);

        var voronoi = d3.select("#hairChart .voronoi")
            .selectAll(".cell")
            .data(cells.filter(function(d) { return typeof d !== "undefined"; }));

        voronoi.exit().remove();

        voronoi.enter()
            .append("path")
                .attr("class", "cell")
            .merge(voronoi)
                .attr("d", function(d, i) { return "M" + d.join("L") + "Z"; })
                .on("mouseover", function (d) {
                    d3.selectAll("#hairChart .line").classed("highlighted", false);
                    d3.select("#hairChart .line." + d.data.geo_id).moveToFront();
                    d3.select("#hairChart .line." + d.data.geo_id).classed('highlighted', true)
                    populateTooltip(d.data.geo_id);
                })
                // .on('mousemove', function (d) {
                //     chartMousemove(d.point.name);
                // })
                .on("mouseout", function (d) {
                    d3.selectAll("#hairChart .line").classed('highlighted', false);
                    d3.select("#hairChart .tooltip").classed("hidden", true);
                });
                // .on("mouseleave", function (d) {
                //     chartMouseleave();
                // });;
    }

    function updateChart(data) {
        // update y axis and position of lines
        yScale.domain(d3.extent(data.map(function(d) { return d.financial_vulnerability_index; })))
            .nice();

        d3.selectAll("#hairChart .y.axis")
            .transition()
            // .duration(3000)
            .call(d3.axisLeft(yScale).ticks(ticksY).tickSize(-chartWidth))
            .call(function(g) { g.selectAll('.domain').remove(); });

        const line = d3.line()
            .defined(d => !isNaN(d["financial_vulnerability_index"]))
            .curve(d3.curveLinear)
            .x(d => xScale(d["date"]))
            .y(d => yScale(d["financial_vulnerability_index"]));

        d3.selectAll("#hairChart .line").transition()
            .attr("d", function(d) { return line(d["values"]); });
    }

    dispatch.on("viewChange.hairChart", function(view) {
        // update line chart when user switches between PC and region view
        // this resets any region filter that was applied
        if(view === "PC") {
            // show region/country filter above chart and reset to show all regions/countries
            d3.select(".changeOverTime .filters").classed("invisible", false);
            d3.select("#regionCountryFilter-button .ui-selectmenu-text").text("Show all");

            d3.selectAll("#hairChart .line.PC").classed("invisible", false);
            d3.selectAll("#hairChart .line.Region").classed("invisible", true);
            d3.select(".changeOverTime .legendLabel").text("Parliamentary constituencies");
        }
        else {
            // hide region/country filter when on region view
            d3.select(".changeOverTime .filters").classed("invisible", true);

            d3.selectAll("#hairChart .line.Region").classed("invisible", false);
            d3.selectAll("#hairChart .line.PC").classed("invisible", true);
            d3.select(".changeOverTime .legendLabel").text("Regions/countries");
        }

        var newData = index_data.filter(function(d) { return d.geo == view; });

        updateChart(newData);
        // updateVoronoi(newData);

        // hide any tooltips that are visible and make sure no lines are highlighted
        d3.select("#hairChart .tooltip").classed("hidden", true);
        d3.selectAll("#hairChart .line").classed("highlighted", false);
        d3.selectAll("#hairChart .line.selected").classed("selected", false);
    });

    dispatch.on("regionFilterChange.hairChart", function(selectedRegion) {
        var newData;

        if(selectedRegion !== "all") {
            d3.selectAll("#hairChart .line")
                .classed("invisible", function(d) { return d["values"][0].country_or_region_id === selectedRegion ? false : true; });

            newData = index_data.filter(function(d) { return d.country_or_region_id === selectedRegion; });
        }
        else {
            d3.selectAll("#hairChart .line")
                .classed("invisible", function(d) { return d["values"][0].geo === "PC" ? false : true; });

            newData = index_data.filter(function(d) { return d.geo === "PC"; });
        }

        updateChart(newData);
        // updateVoronoi(newData);

        // if selected geo is in the selected region, show its tooltip. otherwise, hide tooltip
        if( (selectedGeoID !== null) && !d3.select("#hairChart .line.selected").classed("invisible") ) {
            populateTooltip(selectedGeoID);
        }
        else {
            d3.selectAll("#hairChart .tooltip").classed("hidden", true);
        }
    });

    dispatch.on("geoSelection.hairChart", function(selected_geo_name, selected_geo_id, source) {
        console.log(selected_geo_id, selectedGeoID);
        // if user searched for a PC using the map or a searchbox, override region filter and reset chart
        if(view === "PC" && source !== "hairChart") {
            d3.selectAll("#hairChart .line.PC").classed("invisible", false);
            d3.select("#regionCountryFilter-button .ui-selectmenu-text").text("Show all");

            var newData = index_data.filter(function(d) { return d.geo == "PC"; });
            updateChart(newData);
            // updateVoronoi(newData);
        }

        // highlight line belonging to the PC or region that was searched for
        // also show the tooltip with that geo's name and latest quarter's index value
        d3.selectAll("#hairChart .line").classed("selected", false);
        d3.select("#hairChart .line." + selected_geo_id).classed("selected", true);
        d3.select("#hairChart .line." + selected_geo_id).moveToFront();

        var selected_geo_data = d3.select("#hairChart .line." + selected_geo_id).datum();
        var mostRecentQuarterData = selected_geo_data["values"].filter(function(d) { return d.year === mostRecentYear && d.quarter === mostRecentQuarter; })[0]
        populateTooltip(selected_geo_id);
    });
});

dispatch.on("load.map", function(index_data, search_data, pcs_bboxes, regions_bboxes, mostRecentQuarter, mostRecentYear) {
    // Filter data to the most recent quarter of data
    // since we only need most recent data for this part of the tool
    var most_recent_qtr_data = index_data.filter(function(d) { return d.quarter === mostRecentQuarter && d.year === mostRecentYear; });

    initMap(most_recent_qtr_data);

    var data = makeData(most_recent_qtr_data, "National", "");

    var stickChartConfig = {
        width: d3.select("#panelIndexChart").node().getBoundingClientRect().width,
        height: 28,
        margins: {
            top: 10,
            right: 12,
            bottom: 40,
            left: 5
        }
    };

    var range = d3.extent(most_recent_qtr_data, function(d) { return d["financial_vulnerability_index"]; });

    makeStickChart("panelIndexChart", "financial_vulnerability_index", data, range, stickChartConfig);
    populateComponentsPanel(data, "National");

    dispatch.on("viewChange.map", function(view) {
        // when the user switches to a new view, update the map to show that view
        // and reset the charts to only show the UK average
        if(view === "PC") {
            map.setLayoutProperty("PC-fill", "visibility", "visible");
            map.setLayoutProperty("PC-borders", "visibility", "visible");
            map.setLayoutProperty("PC-hover-borders", "visibility", "visible");
            map.setLayoutProperty("Region-fill", "visibility", "none");
            map.setLayoutProperty("Region-borders", "visibility", "none");
            map.setLayoutProperty("Region-hover-borders", "visibility", "none");
        }
        else {
            map.setLayoutProperty("PC-fill", "visibility", "none");
            map.setLayoutProperty("PC-borders", "visibility", "none");
            map.setLayoutProperty("PC-hover-borders", "visibility", "none");
            map.setLayoutProperty("Region-fill", "visibility", "visible");
            map.setLayoutProperty("Region-borders", "visibility", "visible");
            map.setLayoutProperty("Region-hover-borders", "visibility", "visible");
        }

        var data = makeData(most_recent_qtr_data, "National", "");

        updateStickChart("panelIndexChart", "financial_vulnerability_index", data, stickChartConfig);
        populateComponentsPanel(data, "National");
    });

    dispatch.on("geoSelection.map", function(selected_geo_name, selected_geo_id, source) {
        var bounds = (view === "PC") ? pcs_bboxes[selected_geo_id]["bounds"] : regions_bboxes[selected_geo_id]["bounds"];
        zoomIn(bounds);

        var data = makeData(most_recent_qtr_data, view, selected_geo_id);

        updateStickChart("panelIndexChart", "financial_vulnerability_index", data, stickChartConfig);
        populateComponentsPanel(data, view);
    });

    dispatch.on("mapMouseover.map", function(hovered_geo_id) {
        var data = makeData(most_recent_qtr_data, view, hovered_geo_id);

        updateStickChart("panelIndexChart", "financial_vulnerability_index", data, stickChartConfig);
        populateComponentsPanel(data, view);
    });

    dispatch.on("mapMouseout.map", function() {
        // if clicked_geo_id is not null (i.e., a geo was searched for or clicked on in the map),
        // populate the Financial Distress Index and Component Scores sections with that geo's info
        // otherwise, populate those parts with national data only
        if(selectedGeoID) {
            var data = makeData(most_recent_qtr_data, view, selectedGeoID);
            updateStickChart("panelIndexChart", "financial_vulnerability_index", data, stickChartConfig);
            populateComponentsPanel(data, view);
        }
        else {
            var data = makeData(most_recent_qtr_data, "National", "");
            updateStickChart("panelIndexChart", "financial_vulnerability_index", data, stickChartConfig);
            populateComponentsPanel(data, "National");
        }
    })
});

dispatch.on("load.componentsCharts", function(index_data, search_data, pcs_bboxes, regions_bboxes, mostRecentQuarter, mostRecentYear) {
    // Chart setup - TODO: turn this into a config object
    var width = 300,
        margins = {
                top: 10,
                right: 12,
                bottom: 40,
                left: 25
            },
        ticksY = 5;

    // Mobile
    // if (isMobile) {
    //     ticksX = 5;
    //     margins['right'] = 25;
    // }

    const chartWidth = width - margins['left'] - margins['right'],
          chartHeight = Math.ceil((width * aspectHeight) / aspectWidth) - margins['top'] - margins['bottom'];

    const xScale = d3.scaleTime()
        .domain(d3.extent(index_data.map(function(d) { return d.date; })))
        .range([ 0, chartWidth ]);

    const yScale = d3.scaleLinear()
        .domain([0, 100])
            .nice()
        .range([chartHeight, 0]);

    var lineChartConfig = {
        width: chartWidth,
        height: chartHeight,
        margins: margins,
        ticksY: ticksY,
        xScale: xScale,
        yScale: yScale
    }

    // Filter data to the series we need and then Nest
    var filteredData = makeData(index_data, "National", "");

    const dataSeries = d3.nest()
        .key(function(d) { return d.geo; })
        .entries(filteredData);

    makeLineChart("financialVulnerabilityIndexChart", "financial_vulnerability_index", dataSeries, lineChartConfig);
    makeLineChart("consumersDefaultChart", "share_of_lowell_consumers_in_default", dataSeries, lineChartConfig);
    makeLineChart("socialBenefitsChart", "share_claiming_social_benefits", dataSeries, lineChartConfig);
    makeLineChart("subprimeLendingChart", "share_with_subprime_lending", dataSeries, lineChartConfig);
    makeLineChart("creditUseChart", "average_credit_use", dataSeries, lineChartConfig);

    // For the stick chart, filter data down to just the latest quarter
    var stickChartData = filteredData.filter(function(d) { return d.quarter === mostRecentQuarter && d.year === mostRecentYear; });

    var stickChartConfig = {
        width: chartWidth,
        height: 15,
        margins: margins
    };

    var rangeEmergencySavings = d3.extent(index_data, function(d) { return d["share_without_emergency_savings"]; });
    var rangeAltFinancialProducts = d3.extent(index_data, function(d) { return d["share_using_alternative_financial_products"]; });

    makeStickChart("emergencySavingsChart", "share_without_emergency_savings", stickChartData, rangeEmergencySavings, stickChartConfig);
    makeStickChart("altFinancialProductsChart", "share_using_alternative_financial_products", stickChartData, rangeAltFinancialProducts, stickChartConfig);

    populateLegend(stickChartData);

    dispatch.on("viewChange.componentsCharts", function(view) {
        // when the user switches to a new view, reset the charts to only show the UK average
        var data = makeData(index_data, "National", "");

        var newDataSeries = d3.nest()
            .key(function(d) { return d.geo; })
            .entries(data);

        updateLineChart("financialVulnerabilityIndexChart", "financial_vulnerability_index", newDataSeries, lineChartConfig);
        updateLineChart("consumersDefaultChart", "share_of_lowell_consumers_in_default", newDataSeries, lineChartConfig);
        updateLineChart("socialBenefitsChart", "share_claiming_social_benefits", newDataSeries, lineChartConfig);
        updateLineChart("subprimeLendingChart", "share_with_subprime_lending", newDataSeries, lineChartConfig);
        updateLineChart("creditUseChart", "average_credit_use", newDataSeries, lineChartConfig);

        // subset data to most recent quarter for the stick charts
        var stickChartData = data.filter(function(d) { return d.quarter === mostRecentQuarter && d.year === mostRecentYear; });

        updateStickChart("emergencySavingsChart", "share_without_emergency_savings", stickChartData, stickChartConfig);
        updateStickChart("altFinancialProductsChart", "share_using_alternative_financial_products", stickChartData, stickChartConfig);

        populateLegend(stickChartData);
    });

    dispatch.on("geoSelection.componentsCharts", function(selected_geo_name, selected_geo_id, source) {
        var data = makeData(index_data, view, selected_geo_id);

        var newDataSeries = d3.nest()
            .key(function(d) { return d.geo; })
            .entries(data);

        updateLineChart("financialVulnerabilityIndexChart", "financial_vulnerability_index", newDataSeries, lineChartConfig);
        updateLineChart("consumersDefaultChart", "share_of_lowell_consumers_in_default", newDataSeries, lineChartConfig);
        updateLineChart("socialBenefitsChart", "share_claiming_social_benefits", newDataSeries, lineChartConfig);
        updateLineChart("subprimeLendingChart", "share_with_subprime_lending", newDataSeries, lineChartConfig);
        updateLineChart("creditUseChart", "average_credit_use", newDataSeries, lineChartConfig);

        var stickChartData = data.filter(function(d) { return d.quarter === mostRecentQuarter && d.year === mostRecentYear; });

        updateStickChart("emergencySavingsChart", "share_without_emergency_savings", stickChartData, stickChartConfig);
        updateStickChart("altFinancialProductsChart", "share_using_alternative_financial_products", stickChartData, stickChartConfig);

        populateLegend(stickChartData);
    });
});

function makeData(full_dataset, view, geo_id) {
    var data = [];
    var nationalData = full_dataset.filter(function(d) { return d.geo === "National"; });

    if(view === "PC") {
        var pcData = full_dataset.filter(function(d) { return d.geo_id === geo_id; });
        var region_id = pcData[0].country_or_region_id;
        var regionData = full_dataset.filter(function(d) { return d.geo_id === region_id; });
        return data.concat(pcData, regionData, nationalData);
    }
    else if(view === "Region") {
        var regionData = full_dataset.filter(function(d) { return d.geo_id === geo_id; });
        return data.concat(regionData, nationalData);
    }

    return nationalData;
}

function makeLineChart(elementID, metric, data, config) {
    // Add y-axis title to the change over time chart
    if(elementID === "#hairChart") {
        const yAxisTitle = d3.select("#" + elementID)
            .append('div')
                .attr('class', 'axis-title')
                .text('Financial vulnerablity index');
    }

    /*
     * Create the root SVG element.
     */
    const chartElement = d3.select("#" + elementID)
        .append('svg')
            .attr('width', config.width + config.margins['left'] + config.margins['right'])
            .attr('height', config.height + config.margins['top'] + config.margins['bottom'])
        .append('g')
            .attr('transform', 'translate(' + config.margins['left'] + ',' + config.margins['top'] + ')');

    /*
     * Create D3 axes.
     */
     const yAxis = g => g
        .call(d3.axisLeft(config.yScale)
            .ticks(config.ticksY)
            .tickSize(-config.width))
        .call(g => g.selectAll('.domain')
            .remove());

    const xAxis = g => g
        .attr('transform', "translate(0," + config.height + ")")
        .call(d3.axisBottom(config.xScale)
            .tickSizeOuter(0)
            .tickFormat(elementID === "hairChart" && !isMobile ? quarterFormatterLong : quarterFormatterShort));

    /*
     * Render axes to chart.
     */
    chartElement.append('g')
        .attr('class', 'y axis')
        .call(yAxis);

    chartElement.append('g')
        .attr('class', 'x axis')
        .call(xAxis);

    var numTicksX = d3.selectAll('#' + elementID + ' .x.axis .tick')._groups[0].length;

    d3.selectAll('#' + elementID + ' .x.axis .tick')._groups[0].forEach(function(tick, i){
        if(i === 0) {
            var selection = d3.select(tick)
            selection.append('text')
                .text('Q3')
                .attr('class', 'year-label')
                .attr('dy',3)
                .attr('y',30)
                .attr('fill','#000000')
        }
        if(i === numTicksX - 1) {
            var selection = d3.select(tick)
            selection.append('text')
                .text('Q2')  // need to update this number when new data are added
                .attr('class', 'year-label')
                .attr('dy',3)
                .attr('y',30)
                .attr('fill','#000000')
        }
    })

    /*
     * Render lines to chart.
     */
    const line = d3.line()
        .defined(d => !isNaN(d[metric]))
        .curve(d3.curveLinear)
        .x(d => config.xScale(d["date"]))
        .y(d => config.yScale(d[metric]));

    const lines = chartElement.selectAll('.line')
        .data(data, function(d) { return d.key; })
        .enter()
        .append("path")
            .attr('class', function(d) { return elementID === "hairChart" ? "line " + d.values[0].geo + " " + d.values[0].geo_id : "line " + d.key; })
            .attr('d', function(d) { return line(d['values']); });
}

function updateLineChart(elementID, metric, data, config) {
    const line = d3.line()
        .defined(d => !isNaN(d[metric]))
        .curve(d3.curveLinear)
        .x(d => config.xScale(d["date"]))
        .y(d => config.yScale(d[metric]));

    var lines = d3.select("#" + elementID + " svg g")
        .selectAll(".line")
        .data(data, function(d) { return d.key; });

    lines.exit().remove();

    lines.enter()
        .append("path")
            .attr("class", function(d) { return "line " + d.key; })
        .merge(lines)
            .transition()
            .attr("d", function(d) { return line(d.values); });
}

function makeStickChart(elementID, metric, data, range, config) {

    // make the top "table" of numbers and place names
    var table = d3.select("#" + elementID)
        .append("div")
        .attr("class", "container");

    var columns = table.selectAll(".column")
        .data(data)
        .enter()
        .append("div")
            .attr("class", function(d) { return "column " + d.geo; });

    columns.append("div")
        .attr("class", "number")
            .text(function(d) { return metric === "financial_vulnerability_index" ? COMMAFORMAT(d[metric]) : COMMAFORMAT(d[metric]) + "%"; });

    columns.append("div")
        .attr("class", "geoName")
            .text(function(d) { return d.geo_name; });

    // make stick chart
    const xScale = d3.scaleLinear()
        .domain([0, 100])
        .range([0, config.width]);

    var chartElement = d3.select("#" + elementID)
        .append("svg")
            .attr('width', config.width + config.margins['left'] + config.margins['right'])
            .attr('height', config.height + config.margins['top'] + config.margins['bottom'])
        .append('g')
            .attr('transform', 'translate(' + config.margins['left'] + ',' + config.margins['top'] + ')');

    const xAxis = g => g
        .attr('transform', "translate(0," + config.height + ")")
        .call(d3.axisBottom(xScale)
            .ticks(5)
            .tickSizeOuter(0));

    // Shade in range of scores on the x-axis
    var scoreRange = chartElement.append('g')
        .attr('class', 'scoreRange')
        .attr('transform', 'translate(0,' + config.height + ')');

    scoreRange.append('rect')
        .attr('x', xScale(range[0]))
        .attr('y', 0)
        .attr('width', xScale(range[1] - range[0]))
        .attr('height', 23);

    scoreRange.append('text')
        .attr('x', Math.max(53, ( xScale(range[0]) + xScale(range[1]) ) / 2 ))
        .attr('y', 40)
        .text('Range of Scores');


    chartElement.append('g')
        .attr('class', 'x axis')
        .call(xAxis);

    var sticks = chartElement.selectAll(".stick")
        .data(data, function(d) { return d.geo; })
        .enter()
        .append("line")
            .attr("class", function(d) { return "stick " + d.geo ; })
            .attr("x1", function(d) { return xScale(d[metric]); })
            .attr("x2", function(d) { return xScale(d[metric]); })
            .attr("y1", 0)
            .attr("y2", config.height);
}

function updateStickChart(elementID, metric, data, config) {
    var columns = d3.select("#" + elementID + " .container")
        .selectAll(".column")
        .data(data);

    columns.exit().remove();

    var columnsEnter = columns.enter()
        .append("div")

    columnsEnter.append("div")
        .attr("class", "number");

    columnsEnter.append("div")
        .attr("class", "geoName");

    columnsEnter = columnsEnter.merge(columns)
        .attr("class", function(d) { return "column " + d.geo; });

    columnsEnter.select(".number")
        .text(function(d) { return metric === "financial_vulnerability_index" ? COMMAFORMAT(d[metric]) : COMMAFORMAT(d[metric]) + "%"; });

    columnsEnter.select(".geoName")
        .text(function(d) { return d.geo_name; });

    const xScale = d3.scaleLinear()
        .domain([0, 100])
        .range([0, config.width]);

    var sticks = d3.select("#" + elementID + " svg g")
        .selectAll(".stick")
        .data(data, function(d) { return d.geo; });

    sticks.exit().remove();

    sticks.enter()
        .append("line")
            .attr("class", function(d) { return "stick " + d.geo; })
        .merge(sticks)
        .transition()
            .attr("class", function(d) { return "stick " + d.geo ; })
            .attr("x1", function(d) { return xScale(d[metric]); })
            .attr("x2", function(d) { return xScale(d[metric]); })
            .attr("y1", 0)
            .attr("y2", config.height);
}

function populateLegend(data) {
    // populate the legend that appears below the Financial Vulnerability
    // Index chart in the Go Deeper section

    var legend = d3.select(".components .legend");

    if(data.length === 1) {
        legend.select(".legendEntry.pc").classed("hidden", true);
        legend.select(".legendEntry.region").classed("hidden", true);
    }
    else if(data.length === 2) {
        legend.select(".legendEntry.pc").classed("hidden", true);
        legend.select(".legendEntry.region").classed("hidden", false);

        legend.select(".legendLabel.region").text(data.filter(function(d) { return d.geo === "Region"; })[0]["geo_name"]);
    }
    else {
        legend.select(".legendEntry.pc").classed("hidden", false);
        legend.select(".legendEntry.region").classed("hidden", false);

        legend.select(".legendLabel.pc").text(data.filter(function(d) { return d.geo === "PC"; })[0]["geo_name"]);
        legend.select(".legendLabel.region").text(data.filter(function(d) { return d.geo === "Region"; })[0]["geo_name"]);
    }
}

function populateComponentsPanel(data, view) {
    // show or hide bars based on which geo is selected
    if(data.length === 1) {
        d3.selectAll(".componentScores .chart .PC").style("display", "none");
        d3.selectAll(".componentScores .chart .Region").style("display", "none");
    }
    else if(data.length === 2) {
        d3.selectAll(".componentScores .chart .PC").style("display", "none");
        d3.selectAll(".componentScores .chart .Region").style("display", "block");
    }
    else {
        d3.selectAll(".componentScores .chart .PC").style("display", "block");
        d3.selectAll(".componentScores .chart .Region").style("display", "block");
    }

    var metricElementMap = {
        inDefault: "share_of_lowell_consumers_in_default",
        socialBenefits: "share_claiming_social_benefits",
        subprimeLending: "share_with_subprime_lending",
        creditUse: "average_credit_use",
        emergencySavings: "share_without_emergency_savings",
        altFinancialProducts: "share_using_alternative_financial_products"
    }

    Object.keys(metricElementMap).forEach(function(element) {
        // the numbers in the table are for the most specific geography selected
        populateTableNumbers(element, view);

        // adjust length of bars
        d3.select("." + element + " .National")
            .style("width", data.filter(function(d) { return d.geo === "National"; })[0][metricElementMap[element]] + "%");

        if(data.length === 3) {
            d3.select("." + element + " .PC")
                .style("width", data.filter(function(d) { return d.geo === "PC"; })[0][metricElementMap[element]] + "%");
        }

        if(data.length >= 2) {
            d3.select("." + element + " .Region")
                .style("width", data.filter(function(d) { return d.geo === "Region"; })[0][metricElementMap[element]] + "%");
        }
    });

    function populateTableNumbers(element, view) {
        d3.select("." + element + " .number")
            .attr("class", "number " + view + "Number")
            .text(COMMAFORMAT(data.filter(function(d) { return d.geo === view; })[0][metricElementMap[element]]) + "%");
    }

    d3.selectAll(".componentScores .chart div").on("mouseover", function() {
        var hoveredView = d3.select(this).attr("class");

        // populate table with numbers corresponding to the geo level of the bar that's hovered over
        // (i.e., if hovering over the region bar, show region values in the table)
        Object.keys(metricElementMap).forEach(function(element) {
            populateTableNumbers(element, hoveredView);
        });

    });

    d3.selectAll(".componentScores .chart div").on("mouseout", function() {
        Object.keys(metricElementMap).forEach(function(element) {
            populateTableNumbers(element, view);
        });
    });
}

function initMap(index_data){

    mapboxgl.accessToken = 'pk.eyJ1IjoidXJiYW5pbnN0aXR1dGUiLCJhIjoiTEJUbmNDcyJ9.mbuZTy4hI_PWXw3C3UFbDQ';

    map = new mapboxgl.Map({
        attributionControl: false,
        container: 'map',
        style: 'mapbox://styles/urbaninstitute/ckjkfrl3g1jqk19mee5uwvubf',
        center: [-2.5, 54.356],
        zoom: 4.5,
        maxZoom: 11,
        minZoom: 3.5
    });

    var hoverGeoID = null, // track which geo is mousedover
        clickedGeoID = null,
        hoverGeoID_orig,
        clickedGeoID_orig;

    map.on('load', function() {

        // make the tract outlines in the *-hover-borders layer transparent initially
        // as geos are hovered over, that geo's border's opacity will be set to 1
        map.setPaintProperty(
            'PC-hover-borders',
            'line-opacity',
            [
                'case',
                ['boolean', ['feature-state', 'highlight'], false],
                1,
                0
            ]
        );

        map.setPaintProperty(
            'Region-hover-borders',
            'line-opacity',
            [
                'case',
                ['boolean', ['feature-state', 'highlight'], false],
                1,
                0
            ]
        );

        // disable map rotation using right click + drag
        map.dragRotate.disable();

        // disable map rotation using touch rotation gesture
        map.touchZoomRotate.disableRotation();

        // on tablet and phone screens, disable map zoom when using scroll
        if(d3.select(".container").node().getBoundingClientRect().width < 1000) {
            map.scrollZoom.disable();
        }

        // hover behavior adapted from: https://docs.mapbox.com/help/tutorials/create-interactive-hover-effects-with-mapbox-gl-js/
        // also a good resource: https://blog.mapbox.com/going-live-with-electoral-maps-a-guide-to-feature-state-b520e91a22d
        map.on('mousemove', 'PC-fill', function(e) { // detect mousemove on the fill layer instead of stroke layer so correct geo is highlighted

            map.getCanvas().style.cursor = 'pointer';

            // Check whether features exist
            if (e.features.length > 0) {

                // If geoID for the hovered feature is not null,
                // use removeFeatureState to reset to the default behavior
                if (hoverGeoID) {
                    map.removeFeatureState({
                        source: 'composite',  // can find what the source and sourceLayer are from console logging e.features[0]["layer"]
                        sourceLayer: 'pcsid',
                        id: hoverGeoID
                    });
                }

                hoverGeoID = e.features[0]["id"]; // this is the Mapbox numeric id
                hoverGeoID_orig = e.features[0]["properties"]["geo_id"]; // this is the ID that links to the rest of the data

                // When the mouse moves over the tract-hover-strokes layer, update the
                // feature state for the feature under the mouse
                map.setFeatureState({
                    source: 'composite',
                    sourceLayer: 'pcsid',
                    id: hoverGeoID
                },
                {
                    highlight: true
                });

                dispatch.call("mapMouseover", this, hoverGeoID_orig);

                // if a geo has been clicked on, make sure it is still highlighted
                if(clickedGeoID) {
                    map.setFeatureState({
                        source: 'composite',
                        sourceLayer: 'pcsid',
                        id: clickedGeoID
                    }, {
                        highlight: true
                    });
                }
            }
        });

        map.on("mouseleave", "PC-fill", function() {

            if (hoverGeoID) {
                map.setFeatureState({
                    source: 'composite',
                    sourceLayer: 'pcsid',
                    id: hoverGeoID
                }, {
                    highlight: false
                });
            }

            hoverGeoID = null;

            // if a geo has been clicked on, keep it highlighted
            if(clickedGeoID) {
                map.setFeatureState({
                    source: 'composite',
                    sourceLayer: 'pcsid',
                    id: clickedGeoID
                }, {
                    highlight: true
                });
            }

            dispatch.call("mapMouseout", this);

            // Reset the cursor style
            map.getCanvas().style.cursor = '';
        });

        map.on("click", "PC-fill", function(e) {

            if(e.features.length > 0) {
                // stop highlighting any previously clicked on tracts
                if (clickedGeoID) {
                    map.removeFeatureState({
                        source: 'composite',
                        sourceLayer: 'pcsid',
                        id: clickedGeoID
                    });
                }

                clickedGeoID = e.features[0].id;
                clickedGeoID_orig = e.features[0].properties["geo_id"];
                clickedGeoName = e.features[0].properties["PCON17NM"];
                selectedGeoID = clickedGeoID_orig;

                map.setFeatureState({
                    source: 'composite',
                    sourceLayer: 'pcsid',
                    id: clickedGeoID
                },
                {
                    highlight: true
                });

                dispatch.call("geoSelection", this, clickedGeoName, clickedGeoID_orig, "map");
            }
        });

        // repeat above setup for the region layers
        map.on('mousemove', 'Region-fill', function(e) {

            map.getCanvas().style.cursor = 'pointer';

            if (e.features.length > 0) {

                if (hoverGeoID) {
                    map.removeFeatureState({
                        source: 'composite',
                        sourceLayer: 'regionsid',
                        id: hoverGeoID
                    });
                }

                hoverGeoID = e.features[0]["id"];
                hoverGeoID_orig = e.features[0]["properties"]["geo_id"];

                map.setFeatureState({
                    source: 'composite',
                    sourceLayer: 'regionsid',
                    id: hoverGeoID
                },
                {
                    highlight: true
                });

                dispatch.call("mapMouseover", this, hoverGeoID_orig);

                if(clickedGeoID) {
                    map.setFeatureState({
                        source: 'composite',
                        sourceLayer: 'regionsid',
                        id: clickedGeoID
                    }, {
                        highlight: true
                    });
                }
            }
        });

        map.on("mouseleave", "Region-fill", function() {

            if (hoverGeoID) {
                map.setFeatureState({
                    source: 'composite',
                    sourceLayer: 'regionsid',
                    id: hoverGeoID
                }, {
                    highlight: false
                });
            }

            hoverGeoID = null;

            if(clickedGeoID) {
                map.setFeatureState({
                    source: 'composite',
                    sourceLayer: 'regionsid',
                    id: clickedGeoID
                }, {
                    highlight: true
                });
            }

            dispatch.call("mapMouseout", this);

            map.getCanvas().style.cursor = '';
        });

        map.on("click", "Region-fill", function(e) {

            if(e.features.length > 0) {
                if (clickedGeoID) {
                    map.removeFeatureState({
                        source: 'composite',
                        sourceLayer: 'regionsid',
                        id: clickedGeoID
                    });
                }

                clickedGeoID = e.features[0].id;
                clickedGeoID_orig = e.features[0].properties["geo_id"];
                clickedGeoName = e.features[0].properties["nuts118nm"];
                selectedGeoID = clickedGeoID_orig;

                map.setFeatureState({
                    source: 'composite',
                    sourceLayer: 'regionsid',
                    id: clickedGeoID
                },
                {
                    highlight: true
                });

                dispatch.call("geoSelection", this, clickedGeoName, clickedGeoID_orig, "map");
            }
        });
    });

    map.addControl(new mapboxgl.NavigationControl({"showCompass": false}), "bottom-right");

    dispatch.on("viewChange.mapboxMap", function(view) {
        // remove any highlighted PCs or regions when the view is changed
        // and reset clickedGeoID to be null
        map.setFeatureState({
            source: 'composite',
            sourceLayer: 'pcsid',
            id: clickedGeoID
        }, {
            highlight: false
        });

        map.setFeatureState({
            source: 'composite',
            sourceLayer: 'regionsid',
            id: clickedGeoID
        }, {
            highlight: false
        });

        clickedGeoID = null;
    });

    dispatch.on("geoSelection.mapboxMap", function(selected_geo_name, selected_geo_id, source) {
        // first clear any previous highlighting (i.e., if the user previously clicked on the map)
        map.setFeatureState({
            source: 'composite',
            sourceLayer: 'pcsid',
            id: clickedGeoID
        }, {
            highlight: false
        });

        map.setFeatureState({
            source: 'composite',
            sourceLayer: 'regionsid',
            id: clickedGeoID
        }, {
            highlight: false
        });

        // get the mapbox ID for the selected geo
        clickedGeoID = index_data.filter(function(d) { return d.geo_id === selected_geo_id})[0]["mapbox_id"];

        if(view === "PC") {
            map.setFeatureState({
                source: 'composite',
                sourceLayer: 'pcsid',
                id: clickedGeoID
            }, {
                highlight: true
            });
        }
        else {
            map.setFeatureState({
                source: 'composite',
                sourceLayer: 'regionsid',
                id: clickedGeoID
            }, {
                highlight: true
            });
        }
    });
}

function zoomIn(bounds) {
    map.fitBounds(
        bounds,
        {
            "padding": 20,
            "duration": 900,
            "essential": true, // If true, then the animation is considered essential and will not be affected by prefers-reduced-motion .
        }
    );
}

var quarterFormatterLong = function(date, i) {
    // display the 4-digit year for Q1, nothing for all other quarters
    // except the first and last quarters of data
    // code from here: https://stackoverflow.com/questions/26921414/d3js-x-axis-data-by-quarter-sub-grouped-by-year

    var year = date.getFullYear(),
        month = date.getMonth(),
        quarter = Math.ceil(month / 3 ) + 1;

    if(quarter === 1 | i === 0 || i === 11) {
        return year;
    }
}

var quarterFormatterShort = function(date, i) {
    // display the 2-digit year for Q1, nothing for all other quarters
    // except the first and last quarters of data
    // code from here: https://stackoverflow.com/questions/26921414/d3js-x-axis-data-by-quarter-sub-grouped-by-year

    var year = date.getFullYear(),
        month = date.getMonth(),
        quarter = Math.ceil(month / 3 ) + 1;

    if(quarter === 1 | i === 0 || i === 11) {
        return "'" + year % 2000;
    }
}

d3.selection.prototype.moveToFront = function() {
    return this.each(function(){
        this.parentNode.appendChild(this);
    });
};

// EVENT LISTENERS
d3.selectAll("input[name='geoType']")
    .on("click", function() { view = getSelectedView();
                              selectedGeoID = null;
                              dispatch.call("viewChange", this, view); });

$( "#regionCountryFilter" ).selectmenu({
    change: function( event, data ) {
        dispatch.call("regionFilterChange", this, data.item.value);
    }
});

d3.select("#locationSearch").on("click", function() { $("#locationSearch").val(""); });

function getSelectedView() {
    return d3.select("input[name='geoType']:checked").node().value;
}
